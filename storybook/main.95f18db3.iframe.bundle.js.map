{"version":3,"file":"main.95f18db3.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;;AAEA;AACA;;AAIA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAKA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAOA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAmBA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAOA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAKA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAaA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAKA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAIA;AAAA;AAGA;AAAA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAeA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AAAA;AAGA;AAAA;AAGA;AACA;AAAA;AAWA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAMA;AAAA;AAKA;AAAA;AAGA;AACA;AAAA;AASA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAMA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAMA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAcA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAMA;AAAA;AAOA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAjdA;AAkdA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/dA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAMA;AAAA;AAGA;AACA;AAAA;AAYA;AAAA;AAGA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAGA;AAAA;AAIA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AAAA;AAmBA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAeA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAEA;AACA;AAAA;AAuBA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAtKA;AAuKA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9PA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAiBA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAaA;AA3DA;AA4DA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAyBA;AACA;AAAA;AAaA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AA7DA;AA8DA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7FA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AA6BA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAuBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AApGA;AAqGA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAjBA;AAkBA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAcA;AACA;AAAA;AASA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AArEA;AAsEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrIA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAiBA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAqBA;AAAA;AAGA;AAAA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAsCA;AA9GA;AA+GA;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtJA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAEA;AAAA;AACA;AACA;AAAA;AAMA;AAnBA;AAoBA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AATA;AAUA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AA+BA;AA/CA;AAgDA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/EA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAIA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAIA;AAxCA;AAyCA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AA3BA;AA4BA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAwBA;AAIA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AAGA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AAEA;AAGA;AAEA;AAFA;AAAA;AAIA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAIA;AACA;AACA;AAAA;AAAA;;;;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACZA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAKA;AAHA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AAvBA;AAyBA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AAAA;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AACA;AAAA;AAAA;AADA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AADA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;ACpFA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AADA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AADA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAFA;AAEA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAFA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAgCA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAFA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AAAA;AADA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtKA;AACA;;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAsBA;AA/BA;AAgCA;AACA;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AClCA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAZA;AAcA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAZA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AADA;AAIA;AACA;AAAA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AAAA;AADA;AAEA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AADA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAGA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAGA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AALA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAAA;AAFA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAsBA;AACA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAGA;AAbA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GA;;AAEA;AACA;AACA;AACA;AAGA;AAAA;AAEA;;AAEA;;AAqBA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAJA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpMA;AAAA;AAaA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AARA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAIA;AAFA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AApCA;;;;;;;;;;;;;AChBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACCA;AACA;;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAGA;AADA;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAIA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AAOA;AA/BA;AAgCA;AACA;;AC9CA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AAAA;;;;;;;;;;;;;ACZA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChDA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://orphic-cypress/./README.md","webpack://orphic-cypress/./stories/CypressUtils/LiterateTestingAndTasks.stories.mdx","webpack://orphic-cypress/./stories/FileFormats/ExternalTest/index.stories.mdx","webpack://orphic-cypress/./stories/MDX/DocsInMDX/index.stories.mdx","webpack://orphic-cypress/./stories/MDX/MDXAutomaticTestFileFormats/CypressTestHooksLikeBeforeEach.stories.mdx","webpack://orphic-cypress/./stories/MDX/MDXAutomaticTestFileFormats/StandardCSFButAutomaticallyRenderTested.stories.mdx","webpack://orphic-cypress/./stories/MDX/MDXAutomaticTestFileFormats/StorybookFiles.stories.mdx","webpack://orphic-cypress/./stories/MDX/MDXFileWithExternalTests/index.stories.mdx","webpack://orphic-cypress/./stories/MockRequests/Overview.stories.mdx","webpack://orphic-cypress/./stories/Overview.stories.mdx","webpack://orphic-cypress/./stories/SkippingAndSelecting/Only.stories.mdx","webpack://orphic-cypress/./stories/SkippingAndSelecting/Overview.stories.mdx","webpack://orphic-cypress/./stories/StubActions/Overview.stories.mdx","webpack://orphic-cypress/./src/storybook/story-code.ts","webpack://orphic-cypress/./.storybook/styles.css?8a47","webpack://orphic-cypress/./.storybook/preview.tsx","webpack://orphic-cypress/./.storybook/preview.tsx-generated-config-entry.js","webpack://orphic-cypress/./stories/CypressUtils/DataCy.stories.tsx","webpack://orphic-cypress/./stories/FileFormats/CypressTestHooksLikeBeforeEach.stories.tsx","webpack://orphic-cypress/./stories/FileFormats/ExternalTest/index.stories.tsx","webpack://orphic-cypress/./stories/FileFormats/StandardCSFButAutomaticallyRenderTested.stories.tsx","webpack://orphic-cypress/./stories/FileFormats/StorybookFiles.stories.tsx","webpack://orphic-cypress/./stories/MDX/CSFStoriesWithArbitraryMDX/index.mdx","webpack://orphic-cypress/./stories/MDX/CSFStoriesWithArbitraryMDX/index.stories.tsx","webpack://orphic-cypress/./stories/MDX/DocsInMDX/index.stories.tsx","webpack://orphic-cypress/./stories/MockRequests/ExternalTests/index.stories.tsx","webpack://orphic-cypress/./stories/MockRequests/InStoryFile.stories.tsx","webpack://orphic-cypress/./stories/SkippingAndSelecting/FullySkipped.stories.tsx","webpack://orphic-cypress/./stories/SkippingAndSelecting/IgnoringViaCyIncludeStories.stories.tsx","webpack://orphic-cypress/./stories/SkippingAndSelecting/SkippedStories.stories.tsx","webpack://orphic-cypress/./stories/StubActions/ExternalTests/index.stories.tsx","webpack://orphic-cypress/./stories/StubActions/WithDefaultExportSettings.stories.tsx","webpack://orphic-cypress/./stories/StubActions/WithStorySettings.stories.tsx","webpack://orphic-cypress/./src/storybook/UnitTest.tsx","webpack://orphic-cypress/./src/storybook/segment-mdx.tsx","webpack://orphic-cypress/./stories/Button/Button.tsx","webpack://orphic-cypress/./stories/Button/ClickCount.tsx","webpack://orphic-cypress/./stories/Button/index.tsx","webpack://orphic-cypress/./stories/SkippingAndSelecting/mdx/index.mdx","webpack://orphic-cypress/./stories/SkippingAndSelecting/mdx/index.ts","webpack://orphic-cypress/./.storybook/components.tsx","webpack://orphic-cypress/./stories/index.tsx","webpack://orphic-cypress/./storybook-init-framework-entry.js","webpack://orphic-cypress/./.storybook/styles.css","webpack://orphic-cypress/./stories/ sync ^\\.(","webpack://orphic-cypress/ignored|/home/runner/work/orphic-cypress/orphic-cypress/node_modules/object-inspect|./util.inspect","webpack://orphic-cypress/./generated-stories-entry.cjs"],"sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <div align=\"center\">\n  <img src=\"https://user-images.githubusercontent.com/9889378/203303857-c5e4682d-afda-4956-bd3b-d54630a7041c.jpeg\" alt=\"Van Gogh's Painting of 'Road with Cypress and Star'\" width=\"400px\" />\n    </div>\n    <h1 {...{\n      \"id\": \"orphic-cypress\"\n    }}>{`Orphic Cypress`}</h1>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}><img parentName=\"a\" {...{\n          \"src\": \"https://raw.githubusercontent.com/storybookjs/brand/main/badge/badge-storybook.svg\",\n          \"alt\": \"Storybook\"\n        }}></img></a>{` `}<a href=\"https://quotapath.github.io/orphic-cypress/\"><img height=\"20\" src=\"https://user-images.githubusercontent.com/9889378/203390045-ba98e185-2701-42d7-9c26-a9dae3446ece.png\" /></a>{` `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/quotapath/orphic-cypress/actions/workflows/ci.yml\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}><img parentName=\"a\" {...{\n          \"src\": \"https://github.com/quotapath/orphic-cypress/actions/workflows/ci.yml/badge.svg\",\n          \"alt\": \"CI\"\n        }}></img></a>{` `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/lcov-report\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}><img parentName=\"a\" {...{\n          \"src\": \"https://quotapath.github.io/orphic-cypress/test-coverage.svg\",\n          \"alt\": \"test coverage\"\n        }}></img></a></p>\n    <p>{`A set of utilities, typescript transformers, and general examples on how to cover storybook stories with cypress component tests.\nIn short, this is a little overengineering, a little black magic, and a lot of documentation on making these kinds of tests as easy and concise as possible.`}</p>\n    <h2 {...{\n      \"id\": \"features\"\n    }}>{`Features`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`A comprehensive set of examples`}</a>{` for using cypress to test storybook with or without tools given here, including some surprising finds `}<a parentName=\"li\" {...{\n          \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/?path=/docs/mdx-file-with-external-tests\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`like how to use composeStories with mdx files`}</a></li>\n      <li parentName=\"ul\">{`An automatic cypress component test executor for plain old storybook stories`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#additional-syntaxes\"\n        }}>{`A series of file syntaxes`}</a>{` to support `}<inlineCode parentName=\"li\">{`.play`}</inlineCode>{` like functionality in story files`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#stubbing-actions\"\n        }}>{`Automatic action stubs and spies`}</a>{` with first level cypress support`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#isolated-component-files-transformer\"\n        }}>{`A typescript transform`}</a>{` that turns your `}<inlineCode parentName=\"li\">{`stories.tsx`}</inlineCode>{` files into cypress test files with just a bit of black magic`}</li>\n      <li parentName=\"ul\">{`Tools for turning `}<a parentName=\"li\" {...{\n          \"href\": \"#intercepting-api-requests\"\n        }}>{`storybook addon mock api calls into cypress intercepts`}</a></li>\n      <li parentName=\"ul\">{`General storybook doc utils for building `}<a parentName=\"li\" {...{\n          \"href\": \"https://quotapath.github.io/orphic-cypress/functions/storybook_story_code.transformSource.html\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`snippets from storysource`}</a>{` or to `}<a parentName=\"li\" {...{\n          \"href\": \"https://quotapath.github.io/orphic-cypress/functions/storybook_segment_mdx.segmentMDX.html\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`segment an mdx file`}</a>{` to use in multiple doc locations.`}</li>\n      <li parentName=\"ul\">{`A fun syntax for `}<a parentName=\"li\" {...{\n          \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/?path=/docs/cypressutils-tasks--arbitrary-task#literate-testing\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`literate testing`}</a></li>\n    </ul>\n    <p>{`See extended module documentation in `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`github pages`}</a>{` and numerous examples at a `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`hosted storybook`}</a></p>\n    <br />\n    <h1 {...{\n      \"id\": \"what-this-is\"\n    }}>{`What this is`}</h1>\n    <p>{`We love storybook and component driven development, but we also love cypress!`}</p>\n    <p>{`We were initially excited about `}<a parentName=\"p\" {...{\n        \"href\": \"https://storybook.js.org/docs/react/writing-tests/interaction-testing\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`storybook's interaction testing`}</a>{`. We even wrote some tests and committed to this as the direction forward, translating over our early enzyme tests.`}</p>\n    <p>{`Ultimately though, we found that the bringing in net-new technologies like jest and testing-library would be too much cognitive overhead and dissonance alongside our end-to-end tests already written using cypress, and our unit tests already using the mocha/chai/sinon stack.`}</p>\n    <p>{`So, we set out to come up with a standard for executing storybook tests in cypress with just the right balance of spooky magic that we have minimal boilerplate, encourage writing tests early and often, and cover stories which don't have explicit tests. Although it's with a heavy heart that we leave behind some of the benefits of storybook's solution, we're thrilled to have test coverage that fits with our existing paradigms. And cypress component testing is really slick.`}</p>\n    <p>{`We also export a few helpers that we find useful for things like creating commands and tasks in typescript.`}</p>\n    <br />\n    <h1 {...{\n      \"id\": \"using-this-package\"\n    }}>{`Using this package`}</h1>\n    <p>{`As is, you could set up cypress component testing following `}<a parentName=\"p\" {...{\n        \"href\": \"https://docs.cypress.io/guides/component-testing/quickstart-react#Configuring-Component-Testing\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`their guide`}</a>{` and write tests like this without any need for the code in this package.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { composeStories } from \"@storybook/testing-react\";\nimport React from \"react\";\n\nimport * as stories from \"./index.stories\";\n\nconst { CompWithLabel } = composeStories(stories);\n\ndescribe(\"SomeComponent\", () => {\n  it(\"should render ok\", () => {\n    cy.mount(<CompWithLabel />);\n  });\n\n  it(\"should show the provided label\", () => {\n    cy.mount(<CompWithLabel />);\n    cy.get(\".typography\").should(\"be.visible\").and(\"contain\", \"test\");\n  });\n});\n`}</code></pre>\n    <p>{`But, that could conceivably be seen as a lot of boilerplate, especially when compared to the `}<inlineCode parentName=\"p\">{`play`}</inlineCode>{` syntax of storybook's interactive tests. You'd have to drop something like this into every directory containing a storybook story and perform the `}<inlineCode parentName=\"p\">{`should render ok`}</inlineCode>{` test to make sure your stories aren't breaking. And we haven't even gotten into things like stubbing actions or mocking API calls which would be duplicative of storybook setup.`}</p>\n    <p>{`Instead we could write some simple utilities so that we can keep the files in the `}<inlineCode parentName=\"p\">{`*.stories.tsx`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const CompWithLabel = () => <Something label=\"test\" />; // was already here\nCompWithLabel.cy = () =>\n  cy.get(\".typography\").should(\"be.visible\").and(\"contain\", \"test\");\n`}</code></pre>\n    <br />\n    <h1 {...{\n      \"id\": \"additional-syntaxes\"\n    }}>{`Additional Syntaxes`}</h1>\n    <p>{`There are 3 available syntaxes for in-file use. See `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/?path=/docs/fileformats-storybookfiles\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`storybook`}</a>{` for comprehensive examples.`}</p>\n    <h2 {...{\n      \"id\": \"function-syntax\"\n    }}><inlineCode parentName=\"h2\">{`function`}</inlineCode>{` syntax`}</h2>\n    <p>{`already shown above is the most succinct`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`CompWithLabel.cy = () =>\n  cy.get(\".typography\").should(\"be.visible\").and(\"contain\", \"test\");\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"object-syntax\"\n    }}><inlineCode parentName=\"h2\">{`object`}</inlineCode>{` syntax`}</h2>\n    <p>{`allows you to tag the test with a description of the expectation and to write multiple tests for the same component`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`CompWithLabel.cy = {\n  \"should contain the 'test' label\": () =>\n    cy.get(\".typography\").should(\"be.visible\").and(\"contain\", \"test\"),\n\n  \"should show an expanded label when clicked\": () => {\n    cy.get(\".typography\").click();\n    cy.get(\".expanded-label\")\n      .should(\"be.visible\")\n      .and(\"contain\", \"more details here\");\n  },\n};\n`}</code></pre>\n    <p>{`Each of these is executed in it's own isolated `}<inlineCode parentName=\"p\">{`it`}</inlineCode>{` function.`}</p>\n    <h2 {...{\n      \"id\": \"cytest-syntax\"\n    }}><inlineCode parentName=\"h2\">{`cyTest`}</inlineCode>{` syntax`}</h2>\n    <p>{`allows the most control but backs off of some of the automatic setup that takes place`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`CompWithLabel.cyTest = (Story) => {\n  it(\"should contain the 'test' label\", () => {\n    cy.mount(<Story />);\n    cy.get(\".typography\").should(\"be.visible\").and(\"contain\", \"test\");\n  });\n\n  it(\"should show an expanded label when clicked\", () => {\n    cy.mount(<Story additionalArgs=\"more details\" />);\n    cy.get(\".typography\").click();\n    cy.get(\".expanded-label\")\n      .should(\"be.visible\")\n      .and(\"contain\", \"more details here\");\n  });\n};\n`}</code></pre>\n    <p>{`This executes within it's own `}<inlineCode parentName=\"p\">{`describe`}</inlineCode>{` block and is useful for providing component props or setup not included in stories, or for writing `}<inlineCode parentName=\"p\">{`before`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`beforeEach`}</inlineCode>{`, etc hooks.`}</p>\n    <h2 {...{\n      \"id\": \"opting-out\"\n    }}>{`Opting out`}</h2>\n    <p>{`You can opt out of allowing any or all of these syntaxes via cypress configuration. See `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/types/config.CyTestConfig.html\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`config module documentation`}</a>{` for more details.`}</p>\n    <br />\n    <h1 {...{\n      \"id\": \"stubbing-actions\"\n    }}>{`Stubbing Actions`}</h1>\n    <p>{`By default, `}<inlineCode parentName=\"p\">{`composeStories`}</inlineCode>{` will not stub your actions. This package introduces `}<inlineCode parentName=\"p\">{`stubStoryActions`}</inlineCode>{` to do this automatically when running in the cypress test mode. See `}<a parentName=\"p\" {...{\n        \"href\": \"md-docs/modules/actions.md#stubstoryactions\"\n      }}>{`its documentation`}</a>{` for manual use.`}</p>\n    <p>{`See `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/?path=/docs/stubactions\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`storybook`}</a>{` for example uses with various file types and configurations, and `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/functions/actions.stubStoryActions.html\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`module docs`}</a>{` for more details`}</p>\n    <p>{`Cypress component test stubs are really slick and the test runner provides a great, interactive interface for debugging`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://user-images.githubusercontent.com/9889378/203308863-105eac48-a70a-4c21-a439-dead63ef0aed.mp4\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`https://user-images.githubusercontent.com/9889378/203308863-105eac48-a70a-4c21-a439-dead63ef0aed.mp4`}</a></p>\n    <br />\n    <h1 {...{\n      \"id\": \"isolated-component-files-transformer\"\n    }}>{`Isolated Component Files Transformer`}</h1>\n    <p>{`TODO`}</p>\n    <br />\n    <h1 {...{\n      \"id\": \"intercepting-api-requests\"\n    }}>{`Intercepting API Requests`}</h1>\n    <p>{`Mocking requests can be done in essentially the same way as any cypress test, via `}<inlineCode parentName=\"p\">{`cy.intercept`}</inlineCode>{`, but having some utils at hand is always nice.`}</p>\n    <p>{`We've used `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/nutboltu/storybook-addon-mock/\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`storybook-addon-mock`}</a>{` for our own storybook, although tempted by mock service workers, because it was dead simple to set up and worked out of the box. It also offers a nice and clean `}<inlineCode parentName=\"p\">{`mockData`}</inlineCode>{` story parameter which we can hook off of. So orphic-cypress exports `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/functions/intercept.mockToCyIntercept.html\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`mockToCyIntercept`}</a>{` which transforms the specified mock objects to intercepts. That's called on `}<inlineCode parentName=\"p\">{`executeCyTests`}</inlineCode>{` and so is automatically invoked on either isolated or non-isolated test runs, but must be manually called for external files.`}</p>\n    <p>{`See `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/storybook/?path=/docs/mockrequests-overview--page\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`storybook files`}</a>{` for example uses.`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/9889378/204159804-a2df1b09-7efe-4a93-8f57-a631f53401ac.png\",\n        \"alt\": \"intercept api requests in cypress\"\n      }}></img></p>\n    <br />\n    <h1 {...{\n      \"id\": \"a-general-overview-of-the-landscape\"\n    }}>{`A General Overview of the Landscape`}</h1>\n    <h2 {...{\n      \"id\": \"what-are-component-tests\"\n    }}>{`What are component tests?`}</h2>\n    <p>{`Component tests are near to unit tests in that they are low-level tests that cover small units of logic, but they also cover React (or other) components specifically and so have some concept of rendering that component in isolation to test against. This is highly preferable to end-to-end testing in that you can test in isolation from the rest of an application without a large amount of setup or database seeding, which means these tests will execute much faster. A lot has been said about component tests, so I won't go into too much detail on what they are or their value, but here's some further reading:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://docs.cypress.io/guides/component-testing/writing-your-first-component-test\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`Cypress: Writing Your First Component Test`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://reactjs.org/docs/testing.html\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`React: Testing Overview`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://storybook.js.org/docs/react/writing-tests/interaction-testing\",\n          \"target\": \"_blank\",\n          \"rel\": \"nofollow noopener noreferrer\"\n        }}>{`Storybook: Interaction Testing`}</a></li>\n    </ul>\n    <p>{`Lets take a simple example: we have a component that shows some copy if the user is not permissioned, but shows some copy and does a bit of logic if they do have access. Here's some pseudo-code of what you'd expect to see as tests:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`it(\"should show copy for a user without permissions\", () => {\n  const element = render(<OurComponent>);\n  expect(element.text).to.equal(\"No soup for you!\");\n});\n\nit(\"should show details for a user \", () => {\n  const element = render(<OurComponent isPermissioned={true} flagCount={4}>);\n  expect(element.text).to.equal(\"You have four flagged items you need to address\");\n  expect(numToWord).to.be.calledOnce.with(4);\n});\n`}</code></pre>\n    <p>{`Storybook stories make fantastic jumping off points for testing because they're fundamentally designed to illustrate common use cases and already perform a majority of the work that'd need to be done to setup for that component in terms of component state and mocking API or function calls.`}</p>\n    <hr></hr>\n    <h3 {...{\n      \"id\": \"nice-to-haves-for-component-tests\"\n    }}>{`Nice-to-haves for component tests`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`They execute quickly`}</li>\n      <li parentName=\"ul\">{`They're as easy as possible to set up with minimal boilerplate`}</li>\n      <li parentName=\"ul\">{`Optional headed execution so that you can visually see whats happening and debug in a real browser`}</li>\n      <li parentName=\"ul\">{`When executing headlessly in CI for instance, screenshots on errors make for similarly easy debugging as local headed execution`}</li>\n    </ul>\n    <hr></hr>\n    <h3 {...{\n      \"id\": \"comparison-of-existing-solutions\"\n    }}>{`Comparison of Existing Solutions`}</h3>\n    <h4 {...{\n      \"id\": \"storybook-interactive-tests\"\n    }}>{`Storybook interactive tests`}</h4>\n    <p>{`This is the standard that we're working against here. They'll look like this when using the story function syntax`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`SomeStory.play = async ({ canvasElement }) => {\n  const canvas = within(canvasElement);\n  expect(canvas.getByTestId(\"Attainment\")).toBeVisible();\n  // Should not see earnings\n  expect(canvas.queryByTestId(\"Earnings\")).toEqual(null);\n  // Should not see more menu\n  expect(canvas.queryByTestId(\"moreMenu-team\")).toEqual(null);\n};\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`Pros:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`Theyre built into storybook so you get to show interactive stories right there`}</li>\n          <li parentName=\"ul\">{`Weve already written some. Pretty smooth experience`}</li>\n          <li parentName=\"ul\"><inlineCode parentName=\"li\">{`actions`}</inlineCode>{` are automatically supplied and are stubs for easy testing`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ul\">{`Cons:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`It requires new knowledge. Jest and testing-library instead of cypress and chai, alongside some specifics to storybook execution`}</li>\n          <li parentName=\"ul\">{`Its a true pain to set up in CI. They have their own test runner in playwrite, but I couldnt get it working with a quick pass in circleci. I built a custom cypress executor, but that broke when we moved to nginx.`}</li>\n        </ul>\n      </li>\n    </ul>\n    <hr></hr>\n    <h4 {...{\n      \"id\": \"cypress-execution-of-builtin-interactive-tests-by-visiting-the-storys-url-or-iframe\"\n    }}>{`Cypress execution of builtin interactive tests by visiting the story's url or iframe`}</h4>\n    <p>{`TODO`}</p>\n    <hr></hr>\n    <h4 {...{\n      \"id\": \"cypress-component-tests-directly-without-storybook\"\n    }}>{`Cypress component tests directly without storybook`}</h4>\n    <p>{`They look like this (example pulled from cypress docs):`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Stepper } from \"./\";\n\nit(\"stepper should default to 0\", () => {\n  cy.mount(<Stepper />);\n  cy.get(counterSelector).should(\"have.text\", \"0\");\n});\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`Pros:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`We already all know cypress and its tooling`}</li>\n          <li parentName=\"ul\">{`It's slick`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ul\">{`Cons:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`distinct from storybook (though see below) and so we lose that interconnectedness`}</li>\n          <li parentName=\"ul\">{`still technically in beta, though its pretty sophisticated and clear theyre following through with it`}</li>\n        </ul>\n      </li>\n    </ul>\n    <hr></hr>\n    <h4 {...{\n      \"id\": \"cypress-component-tests-using-storybook-components-what-this-project-does\"\n    }}>{`Cypress component tests using storybook components. `}<strong parentName=\"h4\">{`What this project does`}</strong></h4>\n    <p>{`These could be written in the storybook file with some type updates, or alongside in a new file. See `}<a parentName=\"p\" {...{\n        \"href\": \"#using-this-package\"\n      }}>{`Using this package`}</a>{` above for an example of what this'll look like.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Pros:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`We already know and love cypress`}</li>\n          <li parentName=\"ul\">{`Uses stories as test cases, which reduces duplication and increases usefulness/documentative natures of both test and story`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ul\">{`Cons:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`Still wont appear in storybook so youd still have to pull up a separate process to see the interactive story/test`}</li>\n          <li parentName=\"ul\">{`currently only works with typescript or javascript story files, not mdx`}</li>\n        </ul>\n      </li>\n    </ul>\n    <hr></hr>\n    <h4 {...{\n      \"id\": \"jest-or-other-headless-execution-of-storybook-interactive-tests\"\n    }}>{`Jest, or other, headless execution of storybook interactive tests:`}</h4>\n    <p>{`You could execute the `}<inlineCode parentName=\"p\">{`.play`}</inlineCode>{` property in jest tests directly, and could likely write out an instrumented mocha/chai or whatever framework to support the same kind of execution.`}</p>\n    <p>{`Here's storybook's own example from `}<a parentName=\"p\" {...{\n        \"href\": \"https://storybook.js.org/addons/@storybook/testing-react\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`testing-react docs`}</a></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`const { InputFieldFilled } = composeStories(stories);\n\ntest(\"renders with play function\", async () => {\n  const { container } = render(<InputFieldFilled />);\n\n  // pass container as canvasElement and play an interaction that fills the input\n  await InputFieldFilled.play({ canvasElement: container });\n\n  const input = screen.getByRole(\"textbox\") as HTMLInputElement;\n  expect(input.value).toEqual(\"Hello world!\");\n});\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`Pros:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`back to tests being visible in storybook through interaction testing addon`}</li>\n          <li parentName=\"ul\">{`simpler headless CI execution than storybook's playwrite executor`}</li>\n        </ul>\n      </li>\n      <li parentName=\"ul\">{`Cons:`}\n        <ul parentName=\"li\">\n          <li parentName=\"ul\">{`only works with .tsx, not .mdx`}</li>\n          <li parentName=\"ul\">{`wed have to build out some infrastructure to support automatic discovery and execution`}</li>\n          <li parentName=\"ul\">{`headless, so wont get screens of component on error, but could still interact in storybook`}</li>\n          <li parentName=\"ul\">{`back to having to know jest + testing-library`}</li>\n        </ul>\n      </li>\n    </ul>\n    <br />\n    <h1 {...{\n      \"id\": \"whats-in-a-name\"\n    }}>{`Whats in a name?`}</h1>\n    <p>{`When it comes to javascript naming, we find ourselves in a realm of mythology and powerful symbolism.\nFrom the Greek cannon, we have the likes of Apollo and Ajax, from more recent invented myths we have Falcor, Mithril, and Zod.\nThe list goes on, and well it should, myths share with programming a deep understanding of the power of language and symbols.\nEven in javascript testing we have Sinon, named for the Greek warrior who lied to the Trojans to convince them that the giant wooden horse at their gates was only a gift, and was totally not filled to the brim with his comrades. What a brilliant name for a mocking library.\nSo you'd think that Cypress would join in on this tradition, the cypress being an ancient tree known throughout human culture. There is a wealth of deep symbolism there. Van Gogh claimed they looked like Egyptian obelisks and painted them with an intense fiery energy literally leaping out of the frame.`}</p>\n    <p>{`But no, if we dig around a bit, we find that `}<a parentName=\"p\" {...{\n        \"href\": \"https://docs.cypress.io/faq/questions/company-faq#Why-the-name-Cypress\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`cypress was named because`}</a></p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`We believe that tests should always pass -- in other words, should always be green. A cypress is an evergreen tree. So, Cypress!`}</p>\n    </blockquote>\n    <p>{`Lame. So utterly lame. So we're naming this after the `}<a parentName=\"p\" {...{\n        \"href\": \"https://repository.brynmawr.edu/cgi/viewcontent.cgi?article=1095&context=classics_pubs\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`Orphic Tablets`}</a>{` which were found in the tombs of the Greeks which contained instructions on the afterlife, wherein a white cypress stands as a guidepost in that dark underworld. Fitting for tests which execute in a different realm.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`You will find in the halls of Hades a spring on the left, and standing by it, a glowing white cypress tree`}</p>\n    </blockquote>\n    <p>{`It's a literary, `}<em parentName=\"p\">{`storybook`}</em>{`, name. Why name a repo which is mostly examples? Just for fun.`}</p>\n    <h1 {...{\n      \"id\": \"prior-art\"\n    }}>{`Prior Art`}</h1>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://www.cypress.io/blog/2021/05/19/cypress-x-storybook-2-0/\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`Cypress's recommendation on component testing storybook`}</a>{` is essentially the 'what you can do without this package'`}</p>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Canvas, Meta, Story } from \"@storybook/addon-docs\";\nimport { UnitTest } from \"../../src/storybook/UnitTest\";\nimport { Title } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta id=\"cypressutils-tasks-and-literate-testing\" mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"literate-testing\"\n    }}>{`Literate Testing`}</h1>\n    <p>{`There is no need for this to be a story instead of a simple `}<inlineCode parentName=\"p\">{`*.cy.ts`}</inlineCode>{` file,\nbut using orphic-cypress enables a fun literate testing syntax where even\nunit tests could be written in mdx and display nicely in storybook for\ndocumentation purposes.`}</p>\n    <p>{`These will show up in docs without any additional lift, however to get them\nto appear on the canvas tab and in cypress canvas, you'll need to use the\n`}<inlineCode parentName=\"p\">{`unitTestDecorator`}</inlineCode>{`.`}</p>\n    <p>{`Sourceloader does not work with mdx files (as far as I can tell), so I'll drop\nsome snippets in here for example's sake.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`<Story\n  name=\"ArbitraryTask\"\n  parameters={{\n    cy: () =>\n      cy.task(\"arbitraryTask\", 2).then(($num) => expect($num).to.equal(2)),\n  }}\n>\n  <UnitTest name=\"ArbitraryTask\" />\n</Story>\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"task-tests\"\n    }}>{`Task Tests`}</h1>\n    <h2 {...{\n      \"id\": \"arbitrary-task\"\n    }}>{`Arbitrary Task`}</h2>\n    <p>{`Should execute an arbitrary task and and get the result from a promise.`}</p>\n    <Story name=\"ArbitraryTask\" parameters={{\n      cy: () => cy.task(\"arbitraryTask\", 2).then($num => expect($num).to.equal(2))\n    }} mdxType=\"Story\">\n  <UnitTest name=\"ArbitraryTask\" description={false} mdxType=\"UnitTest\" />\n    </Story>\n    <h2 {...{\n      \"id\": \"arbitrary-task-with-command-syntax\"\n    }}>{`Arbitrary task with Command Syntax`}</h2>\n    <p>{`Command task for more convenient ergonomics and well typed signature`}</p>\n    <p>{`This story uses `}<inlineCode parentName=\"p\">{`parameters: { cyUnitTest: true }`}</inlineCode>{` to show test code, and\nalso has the test as a string so that its format stays exactly the same\n(babel or others can alter). Note that empty stories can get a little\nfunky looking at least in mdx1.`}</p>\n    <Story name=\"ArbitraryTaskWithCommandSyntax\" parameters={{\n      cy: {\n        \"should execute an arbitrary task via command syntax\": `() => {\n        const expected = 2;\n        cy.arbitraryTask(2).then(($num) => {\n          expect($num).to.equal(expected);\n        });\n      }`\n      },\n      cyUnitTest: true\n    }} mdxType=\"Story\">\n  <></>\n    </Story>\n    <p>{`Source Code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`<Story\n  name=\"ArbitraryTaskWithCommandSyntax\"\n  parameters={{\n    cy: {\n      \"should execute an arbitrary task via command syntax\": \\`() => {\n        const expected = 2;\n        cy.arbitraryTask(2).then(($num) => {\n          expect($num).to.equal(expected);\n        });\n      }\\`,\n    },\n    cyUnitTest: true,\n  }}\n>\n  <></>\n</Story>\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"some-other-formats\"\n    }}>{`Some other formats`}</h2>\n    <p>{`First `}<inlineCode parentName=\"p\">{`.cy`}</inlineCode>{` function with a `}<inlineCode parentName=\"p\">{`description`}</inlineCode>{` prop passed to `}<inlineCode parentName=\"p\">{`UnitTest`}</inlineCode></p>\n    <Story name=\"CyFunction\" parameters={{\n      cy() {\n        cy.arbitraryTask(2).then($num => expect($num).to.equal(2));\n      }\n    }} mdxType=\"Story\">\n  <UnitTest name=\"CyFunction\" description=\"should execute an arbitrary task via command syntax\" mdxType=\"UnitTest\" />\n    </Story>\n    <p>{`Source code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`<Story\n  name=\"CyFunction\"\n  parameters={{\n    cy() {\n      cy.arbitraryTask(2).then(($num) => expect($num).to.equal(2));\n    },\n  }}\n>\n  <UnitTest\n    name=\"CyFunction\"\n    description=\"should execute an arbitrary task via command syntax\"\n  />\n</Story>\n`}</code></pre>\n    <p>{`Then `}<inlineCode parentName=\"p\">{`.cyTest`}</inlineCode>{` function with multiple internal tests, but no description`}</p>\n    <Story name=\"CyTest\" parameters={{\n      cyTest: () => {\n        it(\"should get 3 in return\", () => {\n          cy.arbitraryTask(3).then($num => expect($num).to.equal(3));\n        });\n        // whitespace only allowed in mdx2 unfortunately\n        it(\"should get 4 in return\", () => {\n          cy.arbitraryTask(4).then($num => expect($num).to.equal(4));\n        });\n      }\n    }} mdxType=\"Story\">\n  <></>\n    </Story>\n    <p>{`This one removes the `}<inlineCode parentName=\"p\">{`UnitTest`}</inlineCode>{` component from out of the `}<inlineCode parentName=\"p\">{`Story`}</inlineCode>{`. That\nwill work in docs, which is perhaps good enough, but it won't show up\nin the story itself, and thus won't show in cypress or on canvas tab,\nthough tests will still execute fine. Not sure why you'd really want\nto though.`}</p>\n    <UnitTest name=\"CyTest\" mdxType=\"UnitTest\" />\n    <p>{`Source code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`<Story\n  name=\"CyTest\"\n  parameters={{\n    cyTest: () => {\n      it(\"should get 3 in return\", () => {\n        cy.arbitraryTask(3).then(($num) => expect($num).to.equal(3));\n      });\n      // whitespace only allowed in mdx2 unfortunately\n      it(\"should get 4 in return\", () => {\n        cy.arbitraryTask(4).then(($num) => expect($num).to.equal(4));\n      });\n    },\n  }}\n>\n  <></>\n</Story>\n\nThis one removes the \\`UnitTest\\` ...\n\n<UnitTest name=\"CyTest\" />\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tests-on-tests-on-tests\"\n    }}>{`Tests on tests on tests`}</h2>\n    <p>{`woah there`}</p>\n    <Story name=\"TestsOnTestsOnTests\" parameters={{\n      cy: () => cy.get(\"body\").should(\"contain\", \"literally this sentence\")\n    }} mdxType=\"Story\">\n  <UnitTest name=\"TestsOnTestsOnTests\" description={false} mdxType=\"UnitTest\" />\n    </Story>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const arbitraryTask = () => (\n          <UnitTest name=\"ArbitraryTask\" description={false} />\n        );\narbitraryTask.storyName = 'ArbitraryTask';\narbitraryTask.parameters = { storySource: { source: '<UnitTest name=\\\"ArbitraryTask\\\" description={false} />' }, ...{\n  cy: () => cy.task(\"arbitraryTask\", 2).then($num => expect($num).to.equal(2))\n} };\n\nexport const arbitraryTaskWithCommandSyntax = () => (\n          <></>\n        );\narbitraryTaskWithCommandSyntax.storyName = 'ArbitraryTaskWithCommandSyntax';\narbitraryTaskWithCommandSyntax.parameters = { storySource: { source: '<></>' }, ...{\n  cy: {\n    \"should execute an arbitrary task via command syntax\": `() => {\n        const expected = 2;\n        cy.arbitraryTask(2).then(($num) => {\n          expect($num).to.equal(expected);\n        });\n      }`\n  },\n  cyUnitTest: true\n} };\n\nexport const cyFunction = () => (\n          <UnitTest name=\"CyFunction\" description=\"should execute an arbitrary task via command syntax\" />\n        );\ncyFunction.storyName = 'CyFunction';\ncyFunction.parameters = { storySource: { source: '<UnitTest name=\\\"CyFunction\\\" description=\\\"should execute an arbitrary task via command syntax\\\" />' }, ...{\n  cy() {\n    cy.arbitraryTask(2).then($num => expect($num).to.equal(2));\n  }\n} };\n\nexport const cyTest = () => (\n          <></>\n        );\ncyTest.storyName = 'CyTest';\ncyTest.parameters = { storySource: { source: '<></>' }, ...{\n  cyTest: () => {\n    it(\"should get 3 in return\", () => {\n      cy.arbitraryTask(3).then($num => expect($num).to.equal(3));\n    });\n    // whitespace only allowed in mdx2 unfortunately\n    it(\"should get 4 in return\", () => {\n      cy.arbitraryTask(4).then($num => expect($num).to.equal(4));\n    });\n  }\n} };\n\nexport const testsOnTestsOnTests = () => (\n          <UnitTest name=\"TestsOnTestsOnTests\" description={false} />\n        );\ntestsOnTestsOnTests.storyName = 'TestsOnTestsOnTests';\ntestsOnTestsOnTests.parameters = { storySource: { source: '<UnitTest name=\\\"TestsOnTestsOnTests\\\" description={false} />' }, ...{\n  cy: () => cy.get(\"body\").should(\"contain\", \"literally this sentence\")\n} };\n\nconst componentMeta = { id: 'cypressutils-tasks-and-literate-testing', includeStories: [\"arbitraryTask\",\"arbitraryTaskWithCommandSyntax\",\"cyFunction\",\"cyTest\",\"testsOnTestsOnTests\"],  };\n\nconst mdxStoryNameToKey = {\"ArbitraryTask\":\"arbitraryTask\",\"ArbitraryTaskWithCommandSyntax\":\"arbitraryTaskWithCommandSyntax\",\"CyFunction\":\"cyFunction\",\"CyTest\":\"cyTest\",\"TestsOnTestsOnTests\":\"testsOnTestsOnTests\"};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta, Story } from \"@storybook/addon-docs\";\nimport * as stories from \"./index.stories\";\nimport { Button } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    {/* id here and in story is just for doc permalink purposes */}\n    <Meta component={Button} id=\"external-test\" mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"defining-tests-in-an-external-file\"\n    }}>{`Defining Tests in an External File`}</h1>\n    <Story story={stories.ExternalTest} id=\"external-test\" mdxType=\"Story\" />\n    <p>{`In an external file, you could write a test which used composeStories\nand cy.mount explicitly. In fact, you could do this entirely without this package.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import { composeStories } from \"@storybook/react\";\nimport React from \"react\";\nimport * as stories from \"./index.stories\";\n\nconst { ExternalTest } = composeStories(stories);\n\ndescribe(\"External test file\", () => {\n  it(\"should contain the external label\", () => {\n    cy.mount(<ExternalTest />);\n    cy.dataCy(\"button\").should(\n      \"contain\",\n      \"Will be tested in external .cy file\"\n    );\n  });\n});\n`}</code></pre>\n    <p>{`If the stories feature mdx docs according to `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/storybookjs/storybook/blob/next/code/addons/docs/docs/recipes.md\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`this recipe`}</a>{` (although actually you'll want to include the default export and add `}<inlineCode parentName=\"p\">{`includeStories: []`}</inlineCode>{` which it hints at), then you'll want to override the `}<inlineCode parentName=\"p\">{`includeStories`}</inlineCode>{` in the test file so that `}<inlineCode parentName=\"p\">{`composeStories`}</inlineCode>{` can find the proper tests. That is in fact what this ExternalTest is doing.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`// this is necessary b/c stories here have mdx generated docs\ndelete (stories.default as { includeStories?: string[] }).includeStories;\nconst { ExternalTest } = composeStories(stories);\n`}</code></pre>\n    <p>{`In the story file, define stories exactly as you normally would, although you may\nwant to skip automatic test execution.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export default {\n  component: Button,\n  // otherwise this would do a mount test like Untested.stories.tsx\n  // which would be fine in this case, just redundant\n  cySkip: true,\n};\n\nexport const ExternalTest: ComponentStory<typeof Button> = (args) => (\n  <Button {...args} />\n);\n`}</code></pre>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const __page = () => { throw new Error(\"Docs-only story\"); };\n\n__page.parameters = { docsOnly: true };\n\nconst componentMeta = { id: 'external-test', component: Button, includeStories: [\"__page\"],  };\n\nconst mdxStoryNameToKey = {};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta, Story } from \"@storybook/addon-docs\";\nimport * as stories from \"./index.stories\";\nimport { Button } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta component={Button} id=\"docs-in-mdx\" mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"defining-documentation-in-mdx-files\"\n    }}>{`Defining Documentation in MDX files`}</h1>\n    <Story story={stories.DocsInMDX} name=\"_DocsInMDX_\" mdxType=\"Story\" />\n    <p>{`The storybook preferred way of writing stories in CSF format but adding documentation in MDX files is to follow `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/storybookjs/storybook/blob/next/code/addons/docs/docs/recipes.md#csf-stories-with-mdx-docs\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`this recipe`}</a>{`.`}</p>\n    <p>{`For cypress tests purposes, we'll want to include the default export but then add `}<inlineCode parentName=\"p\">{`includeStories: []`}</inlineCode>{`, which is a pattern hinted at in that documentation but which must have changed slightly. However, for automatic testing purposes, that will be a problem for `}<inlineCode parentName=\"p\">{`composeStories`}</inlineCode>{`. As such, you should add `}<inlineCode parentName=\"p\">{`cyIncludeStories: true`}</inlineCode>{` to your default export. For this repo specifically, we don't want to show the component itself in the docs, so we set `}<inlineCode parentName=\"p\">{`parameters.docs.disable`}</inlineCode>{` to `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{`. All in, the story file looks like this`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import type { ComponentStory } from \"@storybook/react\";\nimport * as React from \"react\";\nimport { Button } from \"../../Button\";\n\n// eslint-disable-next-line storybook/story-exports\nexport default {\n  component: Button,\n  // mdx generated docs\n  includeStories: [],\n  cyIncludeStories: true,\n};\n\nexport const DocsInMDX: ComponentStory<typeof Button> = (args) => (\n  <Button {...args} />\n);\nDocsInMDX.args = {\n  label: \"Documentation provided by mdx file while component is written in csf\",\n};\n// don't show the component in the docs created by mdx\nDocsInMDX.parameters = {\n  docs: { disable: true },\n};\n`}</code></pre>\n    <p>{`and the MDX file looks like, well..., this file. But here's a snippet:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`import { Meta, Story } from '@storybook/addon-docs';\nimport * as stories from './index.stories';\nimport { Button } from '../../Button';\n\n<Meta title=\"Docs In MDX\" component={Button} />\n\n# Defining Documentation in MDX files\n\n<Story story={stories.DocsInMDX} />\n\nThe storybook preferred way of writing stories in CSF format but adding documentation in MDX files...\n`}</code></pre>\n    <p>{`See `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/external-test\"\n      }}>{`External Test`}</a>{` for another example and one in which the tests are external, and so don't need the `}<inlineCode parentName=\"p\">{`cyIncludeStories`}</inlineCode>{` but which will need to override the `}<inlineCode parentName=\"p\">{`includeStories`}</inlineCode>{` manually.`}</p>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const _DocsInMDX_ = stories.DocsInMDX;\n\nconst componentMeta = { id: 'docs-in-mdx', component: Button, includeStories: [\"_DocsInMDX_\"],  };\n\nconst mdxStoryNameToKey = {\"_DocsInMDX_\":\"_DocsInMDX_\"};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta, Subheading, Story } from \"@storybook/addon-docs\";\nimport { Button, Title } from \"stories\";\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n      console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n      return <div {...props}/>\n    };\nconst StoryComp = makeShortcode(\"StoryComp\");\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta component={Button} id=\"mdx-mdxautomatictestfileformats-cypress-test-hooks\" parameters={{\n      cy() {\n        beforeEach(() => {\n          // just something simple to prove this happens at top\n          cy.wrap(\"DefaultCyProperty label\").as(\"wrappedLabel\");\n        });\n      }\n    }} mdxType=\"Meta\" />\n    <Title name=\"DefaultCyProperty\" mdxType=\"Title\" />\n    <p>{`You can add a `}<inlineCode parentName=\"p\">{`cy`}</inlineCode>{` property to meta's parameters to do things like execute\nhooks such as `}<inlineCode parentName=\"p\">{`beforeEach`}</inlineCode>{` to establish test state`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-mdx\"\n      }}>{`<Meta\n  component={Button}\n  parameters={{\n    cy() {\n      beforeEach(() => {\n        // just something simple to prove this happens at top\n        cy.wrap(\"DefaultCyProperty label\").as(\"wrappedLabel\");\n      });\n    },\n  }}\n/>\n\n# Title and description...\n\n<Story\n  name=\"DefaultCyProperty\"\n  parameters={{\n    cy() {\n      cy.get(\"@wrappedLabel\").then((wrappedLabel) =>\n        cy.dataCy(\"button\").should(\"contain\", wrappedLabel)\n      );\n      cy.wrap(\"This will be reset\").as(\"wrappedLabel\");\n    },\n  }}\n>\n  {(args) => <Button {...args} label=\"DefaultCyProperty label\" />}\n</Story>\n`}</code></pre>\n    <Story name=\"DefaultCyProperty\" parameters={{\n      cy() {\n        cy.get(\"@wrappedLabel\").then(wrappedLabel => cy.dataCy(\"button\").should(\"contain\", wrappedLabel));\n        cy.wrap(\"This will be reset\").as(\"wrappedLabel\");\n      }\n    }} mdxType=\"Story\">\n  {args => <Button {...args} label=\"DefaultCyProperty label\" mdxType=\"Button\" />}\n    </Story>\n    <Title name=\"CyTestFunctionBody\" pad mdxType=\"Title\" />\n    <p>{`The .cyTest format can contain hooks like beforeEach directly inside its function body, which is the only way to have such hooks execute for only specific story tests.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-mdx\"\n      }}>{`<Story\n  name=\"CyTestFunctionBody\"\n  parameters={{\n    cyTest(StoryComp) {\n      beforeEach(() => {\n        cy.wrap(\"Before Wrapped label\").as(\"beforeWrappedLabel\");\n      });\n      it(\"should get label arg from default export beforeEach setup\", function () {\n        // function keyword + this instead of .get(\"@alias\") just to show variant\n        cy.mount(<StoryComp label={this.wrappedLabel} />);\n        cy.dataCy(\"button\").should(\"contain\", this.wrappedLabel);\n      });\n      it(\"should get label arg from beforeEach in local cyTest\", function () {\n        cy.mount(<StoryComp label={this.beforeWrappedLabel} />);\n        cy.dataCy(\"button\").should(\"contain\", this.beforeWrappedLabel);\n      });\n    },\n  }}\n>\n  {(args) => <Button {...args} />}\n</Story>\n`}</code></pre>\n    <Story name=\"CyTestFunctionBody\" parameters={{\n      cyTest(StoryComp) {\n        beforeEach(() => {\n          cy.wrap(\"Before Wrapped label\").as(\"beforeWrappedLabel\");\n        });\n        it(\"should get label arg from default export beforeEach setup\", function () {\n          // function keyword + this instead of .get(\"@alias\") just to show variant\n          cy.mount(<StoryComp label={this.wrappedLabel} mdxType=\"StoryComp\" />);\n          cy.dataCy(\"button\").should(\"contain\", this.wrappedLabel);\n        });\n        it(\"should get label arg from beforeEach in local cyTest\", function () {\n          cy.mount(<StoryComp label={this.beforeWrappedLabel} mdxType=\"StoryComp\" />);\n          cy.dataCy(\"button\").should(\"contain\", this.beforeWrappedLabel);\n        });\n      }\n    }} mdxType=\"Story\">\n  {args => <Button {...args} mdxType=\"Button\" />}\n    </Story>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const defaultCyProperty = (args => <Button {...args} label=\"DefaultCyProperty label\" />);\ndefaultCyProperty.storyName = 'DefaultCyProperty';\ndefaultCyProperty.parameters = { storySource: { source: 'args => <Button {...args} label=\\\"DefaultCyProperty label\\\" />' }, ...{\n  cy() {\n    cy.get(\"@wrappedLabel\").then(wrappedLabel => cy.dataCy(\"button\").should(\"contain\", wrappedLabel));\n    cy.wrap(\"This will be reset\").as(\"wrappedLabel\");\n  }\n} };\n\nexport const cyTestFunctionBody = (args => <Button {...args} />);\ncyTestFunctionBody.storyName = 'CyTestFunctionBody';\ncyTestFunctionBody.parameters = { storySource: { source: 'args => <Button {...args} />' }, ...{\n  cyTest(StoryComp) {\n    beforeEach(() => {\n      cy.wrap(\"Before Wrapped label\").as(\"beforeWrappedLabel\");\n    });\n    it(\"should get label arg from default export beforeEach setup\", function () {\n      // function keyword + this instead of .get(\"@alias\") just to show variant\n      cy.mount(<StoryComp label={this.wrappedLabel} />);\n      cy.dataCy(\"button\").should(\"contain\", this.wrappedLabel);\n    });\n    it(\"should get label arg from beforeEach in local cyTest\", function () {\n      cy.mount(<StoryComp label={this.beforeWrappedLabel} />);\n      cy.dataCy(\"button\").should(\"contain\", this.beforeWrappedLabel);\n    });\n  }\n} };\n\nconst componentMeta = { id: 'mdx-mdxautomatictestfileformats-cypress-test-hooks', parameters: {\n  cy() {\n    beforeEach(() => {\n      // just something simple to prove this happens at top\n      cy.wrap(\"DefaultCyProperty label\").as(\"wrappedLabel\");\n    });\n  }\n}, component: Button, includeStories: [\"defaultCyProperty\",\"cyTestFunctionBody\"],  };\n\nconst mdxStoryNameToKey = {\"DefaultCyProperty\":\"defaultCyProperty\",\"CyTestFunctionBody\":\"cyTestFunctionBody\"};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Canvas, Meta, Story, DocsContext } from \"@storybook/addon-docs\";\nimport { Button, Title } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta component={Button} id=\"mdx-mdxautomatictestfileformats-standard-csf\" mdxType=\"Meta\" />\n    <Title mdxType=\"Title\" />\n    <p>{`Simply check if the component renders okay without extra cypress assertions`}</p>\n    <Canvas mdxType=\"Canvas\">\n  <Story name=\"StandardCSFButAutomaticallyRenderTested\" args={{\n        label: \"CSF\"\n      }} mdxType=\"Story\">\n    {args => <Button {...args} mdxType=\"Button\" />}\n  </Story>\n    </Canvas>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const standardCsfButAutomaticallyRenderTested = (args => <Button {...args} />);\nstandardCsfButAutomaticallyRenderTested.storyName = 'StandardCSFButAutomaticallyRenderTested';\nstandardCsfButAutomaticallyRenderTested.args = {\n  label: \"CSF\"\n};\nstandardCsfButAutomaticallyRenderTested.parameters = { storySource: { source: 'args => <Button {...args} />' } };\n\nconst componentMeta = { id: 'mdx-mdxautomatictestfileformats-standard-csf', component: Button, includeStories: [\"standardCsfButAutomaticallyRenderTested\"],  };\n\nconst mdxStoryNameToKey = {\"StandardCSFButAutomaticallyRenderTested\":\"standardCsfButAutomaticallyRenderTested\"};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta, Story } from \"@storybook/addon-docs\";\nimport { Button } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta component={Button} id=\"mdx-mdxautomatictestfileformats-storybookfiles\" mdxType=\"Meta\" />\n    <p>{`.cy is the simplest format, expecting just a function which executes in cypress`}</p>\n    <Story name=\"StoryFunctionWithCyFunction\" parameters={{\n      cy: () => cy.dataCy(\"button\").should(\"contain\", \"Story function\")\n    }} mdxType=\"Story\">\n  {args => <Button {...args} label=\"Story function\" mdxType=\"Button\" />}\n    </Story>\n    <p>{`.cy also allows an object syntax where the text keys become the input for cypress`}<inlineCode parentName=\"p\">{`it`}</inlineCode>{`'s\nand the bodies execute within their own tests.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`export const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\n  args\n) => <Button {...args} label=\"Story object\" />;\n\nStoryFunctionWithCyObject.cy = {\n  \"should contain 'Story object' label\": () =>\n    cy.dataCy(\"button\").should(\"contain\", \"Story object\"),\n\n  \"should not be disabled by default\": () =>\n    cy.dataCy(\"button\").should(\"not.be.disabled\"),\n};\n`}</code></pre>\n    <p>{`becomes`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`describe(\"Story Function With Cy Object\", () => {\n  it(\"should contain 'Story object' label\", () =>\n    cy.dataCy(\"button\").should(\"contain\", \"Story object\"));\n\n  it(\"should not be disabled by default\", () =>\n    cy.dataCy(\"button\").should(\"not.be.disabled\"));\n});\n`}</code></pre>\n    <Story name=\"StoryFunctionWithCyObject\" parameters={{\n      cy: {\n        \"should contain Story object label\": () => cy.dataCy(\"button\").should(\"contain\", \"Story object\"),\n        \"should not be disabled by default\": () => cy.dataCy(\"button\").should(\"not.be.disabled\")\n      }\n    }} mdxType=\"Story\">\n  {args => <Button {...args} label=\"Story object\" mdxType=\"Button\" />}\n    </Story>\n    <p>{`.cyTest offers the most control and is the most verbose.It allows executing test hooks like beforeEach, calling it.skip, or passing new arguments to the story at each test, but requires manually calling cy.mount on the component that comes in as an argument.`}</p>\n    <Story name=\"StoryFunctionWithCyTest\" parameters={{\n      cyTest: Story => {\n        it(\"should contain Story test label\", () => {\n          cy.mount(<Story mdxType=\"Story\" />);\n          cy.dataCy(\"button\").should(\"contain\", \"Story test\");\n        });\n        // very weird, but an empty line would break this!\n        it(\"should accept a disabled prop\", () => {\n          cy.mount(<Story disabled mdxType=\"Story\" />);\n          cy.dataCy(\"button\").should(\"be.disabled\");\n        });\n        it.skip(\"should skip a test\", () => {\n          cy.mount(<Story mdxType=\"Story\" />);\n          cy.dataCy(\"button\").should(\"contain\", \"This test would fail if not skipped\");\n        });\n      }\n    }} mdxType=\"Story\">\n  {args => <Button label=\"Story test\" {...args} mdxType=\"Button\" />}\n    </Story>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const storyFunctionWithCyFunction = (args => <Button {...args} label=\"Story function\" />);\nstoryFunctionWithCyFunction.storyName = 'StoryFunctionWithCyFunction';\nstoryFunctionWithCyFunction.parameters = { storySource: { source: 'args => <Button {...args} label=\\\"Story function\\\" />' }, ...{\n  cy: () => cy.dataCy(\"button\").should(\"contain\", \"Story function\")\n} };\n\nexport const storyFunctionWithCyObject = (args => <Button {...args} label=\"Story object\" />);\nstoryFunctionWithCyObject.storyName = 'StoryFunctionWithCyObject';\nstoryFunctionWithCyObject.parameters = { storySource: { source: 'args => <Button {...args} label=\\\"Story object\\\" />' }, ...{\n  cy: {\n    \"should contain Story object label\": () => cy.dataCy(\"button\").should(\"contain\", \"Story object\"),\n    \"should not be disabled by default\": () => cy.dataCy(\"button\").should(\"not.be.disabled\")\n  }\n} };\n\nexport const storyFunctionWithCyTest = (args => <Button label=\"Story test\" {...args} />);\nstoryFunctionWithCyTest.storyName = 'StoryFunctionWithCyTest';\nstoryFunctionWithCyTest.parameters = { storySource: { source: 'args => <Button label=\\\"Story test\\\" {...args} />' }, ...{\n  cyTest: Story => {\n    it(\"should contain Story test label\", () => {\n      cy.mount(<Story />);\n      cy.dataCy(\"button\").should(\"contain\", \"Story test\");\n    });\n    // very weird, but an empty line would break this!\n    it(\"should accept a disabled prop\", () => {\n      cy.mount(<Story disabled />);\n      cy.dataCy(\"button\").should(\"be.disabled\");\n    });\n    it.skip(\"should skip a test\", () => {\n      cy.mount(<Story />);\n      cy.dataCy(\"button\").should(\"contain\", \"This test would fail if not skipped\");\n    });\n  }\n} };\n\nconst componentMeta = { id: 'mdx-mdxautomatictestfileformats-storybookfiles', component: Button, includeStories: [\"storyFunctionWithCyFunction\",\"storyFunctionWithCyObject\",\"storyFunctionWithCyTest\"],  };\n\nconst mdxStoryNameToKey = {\"StoryFunctionWithCyFunction\":\"storyFunctionWithCyFunction\",\"StoryFunctionWithCyObject\":\"storyFunctionWithCyObject\",\"StoryFunctionWithCyTest\":\"storyFunctionWithCyTest\"};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta, Story } from \"@storybook/addon-docs\";\nimport { ClickCount } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta component={ClickCount} id=\"mdx-file-with-external-tests\" mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"defining-stories-in-mdx\"\n    }}>{`Defining Stories in MDX`}</h1>\n    <p>{`You can define stories in MDX format! I really didn't think this'd work, but if you mimic storybook's own webpack rules for .mdx files, then they act exactly like CSF files.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Meta, Story } from '@storybook/addon-docs';\nimport { ClickCount } from '../../Button';\n\n<Meta id=\"mdx-file-with-external-tests\" component={ClickCount} />\n\n# Whatever Markdown\n\n<Story name=\"MDXFileWithExternalTests\">\n  {(args) => (\n    <>\n      <div>This is a story</div>\n      <ClickCount label=\"In MDX\" {...args} />\n    </>\n  )}\n</Story>\n`}</code></pre>\n    <Story name=\"MDXFileWithExternalTests\" parameters={{\n      docs: {\n        disable: true\n      }\n    }} mdxType=\"Story\">\n  {args => <>\n      <div>This is a story</div>\n      <ClickCount label=\"In MDX\" {...args} mdxType=\"ClickCount\" />\n    </>}\n    </Story>\n    <p>{`And the test would look like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { composeStories } from \"@storybook/react\";\nimport React from \"react\";\n// @ts-ignore\nimport * as stories from \"./index.stories.mdx\";\n\nconst { mdxFileWithExternalTests: MDXFileWithExternalTests } =\n  composeStories(stories);\n\ndescribe(\"External test file\", () => {\n  it(\"should contain the external label\", () => {\n    const onClick = cy.stub();\n    cy.mount(<MDXFileWithExternalTests onClick={onClick} />);\n    cy.dataCy(\"button\").should(\"contain\", \"In MDX\");\n    cy.dataCy(\"button\")\n      .click()\n      .then(() => expect(onClick).to.be.calledOnceWith(0));\n  });\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"caveats\"\n    }}>{`Caveats`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Component name comes in camelCased.`}</li>\n      <li parentName=\"ul\">{`Same as for external files in general, some manual setup and currently the global parameters must be provided directly to support automocking.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"webpack-config-in-cypressconfigts\"\n    }}>{`Webpack config in cypress.config.ts`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import webpackConfig from \"./webpack.config\";\n\n// ...\n\nwebpackConfig.module.rules.push({\n  test: /\\\\.mdx$/,\n  use: [\n    {\n      loader: \"babel-loader\",\n      options: {\n        babelrc: false,\n        configFile: false,\n        sourceType: \"unambiguous\",\n        presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n        // possible copying over more could help with caveats or fix edgecases I've yet to find\n      },\n    },\n    {\n      loader: require.resolve(\"@storybook/mdx1-csf/loader\"),\n      options: { skipCsf: false },\n      // same here, there were two \\`remark\\` options\n    },\n  ],\n});\n\nexport default defineConfig({\n  component: {\n    devServer: {\n      framework: \"react\",\n      bundler: \"webpack\",\n      webpackConfig,\n    },\n    // ...\n  },\n});\n`}</code></pre>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const mdxFileWithExternalTests = (args => <>\n      <div>This is a story</div>\n      <ClickCount label=\"In MDX\" {...args} />\n    </>);\nmdxFileWithExternalTests.storyName = 'MDXFileWithExternalTests';\nmdxFileWithExternalTests.parameters = { storySource: { source: 'args => <>\\n      <div>This is a story</div>\\n      <ClickCount label=\\\"In MDX\\\" {...args} />\\n    </>' }, ...{\n  docs: {\n    disable: true\n  }\n} };\n\nconst componentMeta = { id: 'mdx-file-with-external-tests', component: ClickCount, includeStories: [\"mdxFileWithExternalTests\"],  };\n\nconst mdxStoryNameToKey = {\"MDXFileWithExternalTests\":\"mdxFileWithExternalTests\"};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta } from \"@storybook/addon-docs\";\nimport readme from \"../../README.md\";\nimport { segmentMDX } from \"../../src/storybook/segment-mdx\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta id=\"mockrequests-overview\" mdxType=\"Meta\" />\n    <>{segmentMDX(readme)[\"intercepting-api-requests\"].full}</>\n    <h2 {...{\n      \"id\": \"further-afield\"\n    }}>{`Further afield`}</h2>\n    <p>{`If you really wanted the storybook mock itself to work, you could pull in `}<inlineCode parentName=\"p\">{`decorators`}</inlineCode>{` e.g.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { decorators } from \"storybook-addon-mock/dist/cjs/preset/preview\";\nSomeStory.decorators = decorators;\n`}</code></pre>\n    <p>{`though I haven't quite found out how you'd make expectations against those mocked requests. Reading from addon channel emit is promising, but didn't quite work and would still present challenges for proper waiting.`}</p>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const __page = () => { throw new Error(\"Docs-only story\"); };\n\n__page.parameters = { docsOnly: true };\n\nconst componentMeta = { id: 'mockrequests-overview', includeStories: [\"__page\"],  };\n\nconst mdxStoryNameToKey = {};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta } from \"@storybook/addon-docs\";\nimport Readme from \"../README.md\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta id=\"overview\" mdxType=\"Meta\" />\n    <Readme mdxType=\"Readme\" />\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const __page = () => { throw new Error(\"Docs-only story\"); };\n\n__page.parameters = { docsOnly: true };\n\nconst componentMeta = { id: 'overview', includeStories: [\"__page\"],  };\n\nconst mdxStoryNameToKey = {};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta } from \"@storybook/addon-docs\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"selecting-stories-with-cyonly\"\n    }}>{`Selecting stories with .cyOnly`}</h1>\n    <p><inlineCode parentName=\"p\">{`cyOnly`}</inlineCode>{` property on either the default export or individual stories effectively\ncalls the cypress test with `}<inlineCode parentName=\"p\">{`describe.only`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`it.only`}</inlineCode>{`, restively.`}</p>\n    <p>{`That should be used with caution of course, e.g. actually including something\nlike these tests would effectively narrow down which tests were running in a major way,\nespecially in the non-isolated, 'mount' test.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`export default { component: Button };\n\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);\n\nNotSkippedFunction.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Story function\");\n\nNotSkippedFunction.cyOnly = true;\n\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);\n\nSkippedFunction.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\");\n\nexport const NotSkippedObject = {\n  args: { label: \"Another\" },\n  cy: () => cy.dataCy(\"button\").should(\"contain\", \"Another\"),\n  cyOnly: true,\n};\n\nexport const SkippedObject = {\n  args: { label: \"Another\" },\n  cy: () => cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\"),\n};\n`}</code></pre>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const __page = () => { throw new Error(\"Docs-only story\"); };\n\n__page.parameters = { docsOnly: true };\n\nconst componentMeta = { includeStories: [\"__page\"],  };\n\nconst mdxStoryNameToKey = {};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta } from \"@storybook/addon-docs\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"skipping-and-selecting-files\"\n    }}>{`Skipping and Selecting Files`}</h1>\n    <p>{`Stories can be skipped or selected via 'only' by a vareity of means.`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/docs/skippingandselecting-fullyskipped--skipped\"\n        }}>{`.cySkip`}</a>{` on default export`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/docs/skippingandselecting-skippedstories--skipped\"\n        }}>{`.cySkip`}</a>{` per story`}</li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/docs/ignoring-via-cyincludestories--not-skipped-function\"\n        }}>{`.cyIncludeFiles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"/docs/skippingandselecting-only--page\"\n        }}>{`.cyOnly`}</a></li>\n    </ul>\n    <p>{`See the examples in these stories\nand see the types of\n`}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/types/types.WithCy.html\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`WithCy`}</a>{`\nfor each story and\n`}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/types/types.StoryFileCyExtension.html\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`StoryFileCyExtension`}</a>{`\nfor the default export additions in particular for detailed module documentation.`}</p>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const __page = () => { throw new Error(\"Docs-only story\"); };\n\n__page.parameters = { docsOnly: true };\n\nconst componentMeta = { includeStories: [\"__page\"],  };\n\nconst mdxStoryNameToKey = {};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { assertIsFn, AddContext } from \"@storybook/addon-docs\";\n\nimport { Meta } from \"@storybook/addon-docs\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nfunction MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Meta id=\"stubactions-overview\" mdxType=\"Meta\" />\n    <h1 {...{\n      \"id\": \"stubbing-actions\"\n    }}>{`Stubbing Actions`}</h1>\n    <p>{`This library provides tools for automatic action stubbing based on `}<inlineCode parentName=\"p\">{`args`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`argTypes`}</inlineCode>{` and the `}<inlineCode parentName=\"p\">{`argTypesRegex`}</inlineCode>{`.`}</p>\n    <p>{`See these tests for example uses with various file types and configurations, and `}<a parentName=\"p\" {...{\n        \"href\": \"https://quotapath.github.io/orphic-cypress/functions/actions.stubStoryActions.html\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}>{`module docs`}</a>{`\nfor more details`}</p>\n    <p>{`Cypress component test stubs are really slick and the test runner provides a great, interactive interface for debugging`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://user-images.githubusercontent.com/9889378/203308863-105eac48-a70a-4c21-a439-dead63ef0aed.mp4\",\n        \"target\": \"_blank\",\n        \"rel\": \"nofollow noopener noreferrer\"\n      }}><img parentName=\"a\" {...{\n          \"src\": \"https://user-images.githubusercontent.com/9889378/203309810-fe715890-3236-46a2-99f6-680bb6c39235.gif\",\n          \"alt\": \"stub-actions\"\n        }}></img></a></p>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n\nexport const __page = () => { throw new Error(\"Docs-only story\"); };\n\n__page.parameters = { docsOnly: true };\n\nconst componentMeta = { id: 'stubactions-overview', includeStories: [\"__page\"],  };\n\nconst mdxStoryNameToKey = {};\n\ncomponentMeta.parameters = componentMeta.parameters || {};\ncomponentMeta.parameters.docs = {\n  ...(componentMeta.parameters.docs || {}),\n  page: () => <AddContext mdxStoryNameToKey={mdxStoryNameToKey} mdxComponentAnnotations={componentMeta}><MDXContent /></AddContext>,\n};\n\nexport default componentMeta;","import type { LocationsMap } from \"@storybook/source-loader\";\nimport type { StoryContext } from \"@storybook/types\";\n\nconst regex = {\n  /** Any comment syntax (really, with any number of stars) with story-code at start */\n  init: \"(//|/\\\\*+)(\\\\s+)?story-code(\\\\s+?)\",\n  /**\n   * Include from start of file to after default block,\n   * can be defined on @end line or 1 after end\n   */\n  includeStart: \"@include-start\",\n  /** Include the default block, can be defined on @end line or 1 after end */\n  includeDefault: \"@include-default\",\n};\n\n/**\n * Create named capture groups for @skip-end etc. A match but no groups\n * means its a normal `@skip` line with no suffix\n */\nconst skipRegex = (() => {\n  const skipParts = [\"end\", \"start\", \"next\"] as const;\n  const skipJoin = skipParts.map((name) => `(?<${name}>-${name})`).join(\"|\");\n  return new RegExp(`${regex.init}@skip(${skipJoin})?`, \"gm\");\n})();\n\n/**\n * Remove lines with @skip, after @skip-next or between @skip-start and\n * @skip-end, all starting with `// story-code `\n *\n * @private\n */\nexport const removeSkips = (codeLines: string[]) => {\n  const skip = { next: false, block: false };\n  const lines = [];\n\n  for (const line of codeLines) {\n    const groups = line.matchAll(skipRegex).next().value?.groups as\n      | Record<\"end\" | \"start\" | \"next\", string | undefined>\n      | undefined;\n    if (skip.block) {\n      if (groups?.end) skip.block = false;\n    } else if (groups?.start) {\n      skip.block = true;\n    } else if (groups?.next) {\n      skip.next = true;\n    } else if (skip.next) {\n      skip.next = false;\n    } else if (groups === undefined) {\n      lines.push(line);\n    }\n  }\n  return lines;\n};\n\n/**\n * Story context augmented by storysource addon\n */\nexport type StoryContextStorySource = StoryContext & {\n  /** parameters extension */\n  parameters: {\n    /** what's added by storysource */\n    storySource: {\n      /** full file as a single string */\n      source: string;\n      /** start/end locations of stories in above source */\n      locationsMap: LocationsMap;\n    };\n  };\n};\n\n/** Options available for story-code's `transformSource` */\nexport type TransformSourceOptions = {\n  /**\n   * storysource doesn't handle ComponentStoryObj syntax well, failing to provide a\n   * location. Passing in `true` here will mean the code block in the story docs\n   * will attempt to include the object itself, overcomming that issue.\n   */\n  includeObjects?: boolean;\n};\n\nconst getDataFromStoryObject = (\n  name: string,\n  allLines: string[]\n): [string, any] => {\n  const componentName = name.replace(/ /g, \"\");\n  // Naive attempt to fix object syntax source\n  const startIndex = allLines.findIndex((line) =>\n    new RegExp(`export const ${componentName}`).test(line)\n  );\n  const endIndex = allLines\n    .slice(startIndex)\n    .findIndex((line) => /^};/.test(line));\n  return [\n    componentName,\n    {\n      startLoc: { col: 0, line: startIndex },\n      endLoc: { col: 0, line: endIndex + startIndex + 1 },\n    },\n  ];\n};\n\n/** Some super simple validation on the location lines */\nconst validateLocation = (\n  allLines: string[],\n  startLine: number,\n  endLine: number\n) => {\n  if (allLines.length < startLine) {\n    throw new Error(\n      `Start line of ${startLine} exceeds file length of ${allLines.length}`\n    );\n  }\n  if (allLines.length < endLine) {\n    throw new Error(\n      `End line of ${endLine} exceeds file length of ${allLines.length}`\n    );\n  }\n};\n\n/** check the comment line and end line for a given directive */\nconst checkForDirective =\n  (linesFromStart: string[], endLineComment: number, endLoc: number) =>\n  (re: keyof typeof regex): boolean =>\n    new RegExp(regex[re]).test(linesFromStart[endLineComment]) ||\n    new RegExp(`${regex.init}${regex[re]}`).test(linesFromStart[endLoc]);\n\n/**\n * Add comment directives that will enable transforming the story source code\n * into the code snippet for the story.\n *\n * Relies on storysource addon\n *\n * Notable issues:\n * * if a story is all object syntax, then it won't have\n *   a storySource at all. That's likely a limitation of source-loader.\n * * If a story name is very long, story-loader's handling can get weird\n *\n * TODO: some notable naive approaches here. Could parse AST to get\n * the default export, to automatically include assignments to stories, or\n * to better parse story objects.\n *\n * TODO: Some of this might be suitable contribution to storysource, but\n * the goals there often different, e.g. to show how to use a component\n * whereas here we're showing how to build stories.\n *\n * TODO: ideas include-render, include-template, include-region\n *\n * All comments start with `// story-code` or with `/*` or `/**` style\n * single line comments. So `// story-code @end SomeComponent @include-default`\n * for example.\n *\n * ## Available commands:\n * * `@end`: end the previous story's code block. Note, this is works across\n *   stories such that any story which does not specify its end which begins\n *   before this use will end at this point. Use named end's if you need specificity\n *   ```ts\n *   const SomeStory: ComponentStory<typeof Comp> = (args) => <Comp {...args} />;\n *   SomeStory.args = { prop: 1 };\n *   // story-code @end\n *   ```\n * * `@end SomeComponent`: same as above, but only mark the end for the given component\n *   ```ts\n *   const SomeStory: ComponentStory<typeof Comp> = (args) => <Comp {...args} />;\n *   const OtherStory: ComponentStory<typeof Comp> = (args) => <Comp {...args} />;\n *   OtherStory.args = { prop: 1 };\n *   // story-code @end OtherStory\n *   ```\n * * `@include-default`: include the default code export. Can occur in an `@end` line\n *   or on the line following a natural or designated end.\n *   ```ts\n *   const SomeStory: ComponentStory<typeof Comp> = (args) => <Comp {...args} />;\n *   SomeStory.args = { prop: 1 };\n *   // story-code @end @include-default\n *   ```\n * * `@include-start`: include from the top of the file through to the default code export.\n *   Can occur in an `@end` line or on the line following a natural or designated end.\n *   ```ts\n *   const SomeStory: ComponentStory<typeof Comp> = (args) => <Comp {...args} />;\n *   // story-code @include-start\n *   ```\n * * `@skip`: Skip the current line\n *   ```ts\n *   const somethingToIgnore = 1; // story-code @skip\n *   ```\n * * `@skip-next`: Skip the next line\n *   ```ts\n *   // story-code @skip-next\n *   const somethingToIgnore = 1;\n *   ```\n * * `@skip-start` and `@skip-end`: Skip a block of text, e.g.\n *   ```ts\n *   // story-code @skip-start\n *   const hideThis = 1;\n *   const andThis = 2;\n *   // story-code @skip-end\n *   ```\n *   There's nothing enforcing that you have to have a @skip-end if you have a @skip-start\n */\nexport const transformSource =\n  (opts: TransformSourceOptions = {}) =>\n  /** Inner function which can be assigned to docs.transformSource */\n  (snippet: string, storyContext: StoryContextStorySource): string => {\n    try {\n      const {\n        parameters: {\n          storySource: { source, locationsMap },\n        },\n        originalStoryFn,\n        id,\n        name,\n      } = storyContext;\n      let componentName = originalStoryFn.name;\n\n      const locationKey = id.split(\"--\")[1];\n      let location = locationsMap[locationKey];\n      const allLines = source.split(\"\\n\");\n\n      if (!location && opts.includeObjects) {\n        [componentName, location] = getDataFromStoryObject(name, allLines);\n      }\n\n      const {\n        startLoc: { line: startLine },\n        endLoc: { line: endLine },\n      } = location;\n\n      validateLocation(allLines, startLine, endLine);\n\n      const linesFromStart = allLines.slice(startLine - 1);\n      const endLineComment = linesFromStart.findIndex((line) =>\n        new RegExp(`${regex.init}@end(\\\\s+)?($|@|${componentName})`).test(line)\n      );\n      const endLoc =\n        endLineComment > 0 ? endLineComment : endLine - startLine + 1;\n\n      const [includeDefault, includeStart] = (\n        [\"includeDefault\", \"includeStart\"] as const\n      ).map(checkForDirective(linesFromStart, endLineComment, endLoc));\n\n      let defaultLines: string[] = [];\n\n      if (includeDefault || includeStart) {\n        // This is pretty naive\n        const defaultStartIndex = allLines.findIndex((line) =>\n          /export default {/.test(line)\n        );\n        if (defaultStartIndex !== -1) {\n          const linesFromDefaultStart = includeStart\n            ? allLines\n            : allLines.slice(defaultStartIndex);\n          if (allLines[defaultStartIndex]?.includes(\"};\")) {\n            defaultLines = [...linesFromDefaultStart.slice(0, 1), \"\"];\n          } else {\n            const endDefaultLine = linesFromDefaultStart.findIndex((line) =>\n              /^};$/.test(line)\n            );\n            if (endDefaultLine > 0) {\n              defaultLines = linesFromDefaultStart.slice(0, endDefaultLine + 1);\n              if (defaultLines.at(-1) !== \"\") {\n                defaultLines = [...defaultLines, \"\"];\n              }\n            }\n          }\n        }\n      }\n\n      return removeSkips([\n        ...defaultLines,\n        ...linesFromStart.slice(0, endLoc),\n      ]).join(\"\\n\");\n    } catch (e) {\n      console.warn(\n        \"Something went wrong while getting the story source for code snippet\",\n        e\n      );\n      return snippet;\n    }\n  };\n","import api from \"!../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./styles.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import {\n  Anchor,\n  Subheading,\n  Canvas,\n  Description,\n  DocsContext,\n  DocsStoryProps,\n  Story,\n  Title as SBTitle,\n} from \"@storybook/addon-docs\";\nimport { themes } from \"@storybook/theming\";\nimport React, { useContext } from \"react\";\nimport { transformSource } from \"../src/storybook/story-code\";\nimport { unitTestDecorator } from \"../src/storybook/UnitTest\";\nimport \"./styles.css\";\n\nconst CustomDocsStory: React.FC<DocsStoryProps> = ({\n  id,\n  name,\n  expanded = true,\n  parameters = {},\n}) => {\n  let description;\n  const { docs } = parameters;\n  if (expanded && docs) {\n    description = docs.description?.story;\n  }\n\n  const subheading = expanded && name;\n\n  return (\n    <Anchor storyId={id ?? \"\"}>\n      {subheading && <Subheading>{subheading}</Subheading>}\n      {description && <Description markdown={description} />}\n      <Canvas>\n        <Story id={id} parameters={parameters} />\n      </Canvas>\n    </Anchor>\n  );\n};\n\nconst CustomStories = () => {\n  const { componentStories } = useContext(DocsContext);\n\n  let stories: DocsStoryProps[] = componentStories();\n  stories = stories.filter((story) => !story.parameters?.docs?.disable);\n  if (!stories || stories?.length === 0) return null;\n\n  return (\n    <>\n      {stories.map(\n        (story) =>\n          story && <CustomDocsStory key={story.id} {...story} expanded />\n      )}\n    </>\n  );\n};\n\n/**\n * This storybook uses nearly the same components for every story as a mechanism\n * for testing. So we can forgo showing the arg table or component at all, opting\n * instead just for the story's description and code block, if provided (default\n * code blocks were essentially useless)\n *\n * @private\n */\nconst DocsPage: React.FC = ({ children }) => (\n  <>\n    <SBTitle />\n    <CustomStories />\n    {children}\n  </>\n);\n\nexport const parameters = {\n  docs: {\n    page: DocsPage,\n    source: { state: \"open\" },\n    transformSource: transformSource({ includeObjects: true }),\n    theme: themes.dark,\n  },\n  viewMode: \"docs\",\n  actions: { argTypesRegex: \"^on[A-Z].*\" },\n  controls: {\n    matchers: {\n      color: /(background|color)$/i,\n      date: /Date$/,\n    },\n    expanded: true,\n    hideNoControlsWarning: true,\n  },\n  options: {\n    storySort: {\n      order: [\n        \"Overview\",\n        \"FileFormats\",\n        \"StubActions\",\n        [\"Overview\"],\n        \"SkippingAndSelecting\",\n        [\"Overview\"],\n        \"MDX\",\n      ],\n    },\n  },\n};\n\nexport const decorators = [unitTestDecorator];\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\nimport { addDecorator, addParameters, addLoader, addArgs, addArgTypes, addArgsEnhancer, addArgTypesEnhancer, setGlobalRender } from '/home/runner/work/orphic-cypress/orphic-cypress/node_modules/@storybook/client-api';\nimport * as config from '/home/runner/work/orphic-cypress/orphic-cypress/.storybook/preview.tsx';\nObject.keys(config).forEach(function (key) {\n  var value = config[key];\n\n  switch (key) {\n    case 'args':\n      {\n        return addArgs(value);\n      }\n\n    case 'argTypes':\n      {\n        return addArgTypes(value);\n      }\n\n    case 'decorators':\n      {\n        return value.forEach(function (decorator) {\n          return addDecorator(decorator, false);\n        });\n      }\n\n    case 'loaders':\n      {\n        return value.forEach(function (loader) {\n          return addLoader(loader, false);\n        });\n      }\n\n    case 'parameters':\n      {\n        return addParameters(_objectSpread({}, value), false);\n      }\n\n    case 'argTypesEnhancers':\n      {\n        return value.forEach(function (enhancer) {\n          return addArgTypesEnhancer(enhancer);\n        });\n      }\n\n    case 'argsEnhancers':\n      {\n        return value.forEach(function (enhancer) {\n          return addArgsEnhancer(enhancer);\n        });\n      }\n\n    case 'render':\n      {\n        return setGlobalRender(value);\n      }\n\n    case 'globals':\n    case 'globalTypes':\n      {\n        var v = {};\n        v[key] = value;\n        return addParameters(v, false);\n      }\n\n    case '__namedExportsOrder':\n    case 'decorateStory':\n    case 'renderToDOM':\n      {\n        return null; // This key is not handled directly in v6 mode.\n      }\n\n    default:\n      {\n        // eslint-disable-next-line prefer-template\n        return console.log(key + ' was not supported :( !');\n      }\n  }\n});","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\nimport dedent from \\\\\\\"ts-dedent\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n};\\\\n\\\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nDataCy.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // nesting data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"[data-cy=click-container]\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // children accessors, don't have to be data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\", \\\\\\\"[data-cy=count]\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // arbitrarily trying the unlikely approach to dataCy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n    cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n  );\\\\n};\\\\n\\\\nDataCy.parameters = {\\\\n  cyUnitTest: true,\\\\n  docs: {\\\\n    description: {\\\\n      story: dedent`\\\\n        \\\\\\\\`dataCy\\\\\\\\` is used to access components by their data-cy designation'.\\\\n        This file is mostly just for test purposes.\\\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\\\n        for more detail \\\\n      `,\\\\n    },\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"DataCy\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":12},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":12}}};\\n    \\nimport * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\nimport dedent from \\\"ts-dedent\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\nimport dedent from \\\\\\\"ts-dedent\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n};\\\\n\\\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nDataCy.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // nesting data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"[data-cy=click-container]\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // children accessors, don't have to be data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\", \\\\\\\"[data-cy=count]\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // arbitrarily trying the unlikely approach to dataCy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n    cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n  );\\\\n};\\\\n\\\\nDataCy.parameters = {\\\\n  cyUnitTest: true,\\\\n  docs: {\\\\n    description: {\\\\n      story: dedent`\\\\n        \\\\\\\\`dataCy\\\\\\\\` is used to access components by their data-cy designation'.\\\\n        This file is mostly just for test purposes.\\\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\\\n        for more detail \\\\n      `,\\\\n    },\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"data-cy\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":12},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":12}}}},},\\n  component: ClickCount,\\n};\\n\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nDataCy.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // nesting data-cy\\n  cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.get(\\\"[data-cy=click-container]\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // children accessors, don't have to be data-cy\\n  cy.dataCy(\\\"click-container\\\", \\\"[data-cy=count]\\\").should(\\\"contain\\\", 0);\\n  // arbitrarily trying the unlikely approach to dataCy\\n  cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n    cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n  );\\n};\\n\\nDataCy.parameters = {\\n  cyUnitTest: true,\\n  docs: {\\n    description: {\\n      story: dedent`\\n        \\\\`dataCy\\\\` is used to access components by their data-cy designation'.\\n        This file is mostly just for test purposes.\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\n        for more detail \\n      `,\\n    },\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"DataCy\":{\"startLoc\":{\"col\":59,\"line\":18},\"endLoc\":{\"col\":1,\"line\":20},\"startBody\":{\"col\":59,\"line\":18},\"endBody\":{\"col\":1,\"line\":20}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\nimport dedent from \\\"ts-dedent\\\";\\n\\nexport default {\\n  component: ClickCount,\\n};\\n\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nDataCy.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // nesting data-cy\\n  cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.get(\\\"[data-cy=click-container]\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // children accessors, don't have to be data-cy\\n  cy.dataCy(\\\"click-container\\\", \\\"[data-cy=count]\\\").should(\\\"contain\\\", 0);\\n  // arbitrarily trying the unlikely approach to dataCy\\n  cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n    cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n  );\\n};\\n\\nDataCy.parameters = {\\n  cyUnitTest: true,\\n  docs: {\\n    description: {\\n      story: dedent`\\n        \\\\`dataCy\\\\` is used to access components by their data-cy designation'.\\n        This file is mostly just for test purposes.\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\n        for more detail \\n      `,\\n    },\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"DataCy\":{\"startLoc\":{\"col\":59,\"line\":10},\"endLoc\":{\"col\":1,\"line\":12},\"startBody\":{\"col\":59,\"line\":10},\"endBody\":{\"col\":1,\"line\":12}}};\n    \nimport * as React from \"react\";\nimport type { ComponentStoryCy } from \"orphic-cypress\";\nimport { ClickCount } from \"stories\";\nimport dedent from \"ts-dedent\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\nimport dedent from \\\\\\\"ts-dedent\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n};\\\\n\\\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nDataCy.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // nesting data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"[data-cy=click-container]\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // children accessors, don't have to be data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\", \\\\\\\"[data-cy=count]\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // arbitrarily trying the unlikely approach to dataCy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n    cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n  );\\\\n};\\\\n\\\\nDataCy.parameters = {\\\\n  cyUnitTest: true,\\\\n  docs: {\\\\n    description: {\\\\n      story: dedent`\\\\n        \\\\\\\\`dataCy\\\\\\\\` is used to access components by their data-cy designation'.\\\\n        This file is mostly just for test purposes.\\\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\\\n        for more detail \\\\n      `,\\\\n    },\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"DataCy\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":12},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":12}}};\\n    \\nimport * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\nimport dedent from \\\"ts-dedent\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\nimport dedent from \\\\\\\"ts-dedent\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n};\\\\n\\\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nDataCy.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // nesting data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"[data-cy=click-container]\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // children accessors, don't have to be data-cy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\", \\\\\\\"[data-cy=count]\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  // arbitrarily trying the unlikely approach to dataCy\\\\n  cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n    cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n  );\\\\n};\\\\n\\\\nDataCy.parameters = {\\\\n  cyUnitTest: true,\\\\n  docs: {\\\\n    description: {\\\\n      story: dedent`\\\\n        \\\\\\\\`dataCy\\\\\\\\` is used to access components by their data-cy designation'.\\\\n        This file is mostly just for test purposes.\\\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\\\n        for more detail \\\\n      `,\\\\n    },\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"data-cy\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":12},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":10},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":12}}}},},\\n  component: ClickCount,\\n};\\n\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nDataCy.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // nesting data-cy\\n  cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.get(\\\"[data-cy=click-container]\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // children accessors, don't have to be data-cy\\n  cy.dataCy(\\\"click-container\\\", \\\"[data-cy=count]\\\").should(\\\"contain\\\", 0);\\n  // arbitrarily trying the unlikely approach to dataCy\\n  cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n    cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n  );\\n};\\n\\nDataCy.parameters = {\\n  cyUnitTest: true,\\n  docs: {\\n    description: {\\n      story: dedent`\\n        \\\\`dataCy\\\\` is used to access components by their data-cy designation'.\\n        This file is mostly just for test purposes.\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\n        for more detail \\n      `,\\n    },\\n  },\\n};\\n\",\"locationsMap\":{\"data-cy\":{\"startLoc\":{\"col\":59,\"line\":18},\"endLoc\":{\"col\":1,\"line\":20},\"startBody\":{\"col\":59,\"line\":18},\"endBody\":{\"col\":1,\"line\":20}}}},\"storySource\":{\"source\":\"import * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\nimport dedent from \\\"ts-dedent\\\";\\n\\nexport default {\\n  component: ClickCount,\\n};\\n\\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nDataCy.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // nesting data-cy\\n  cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.get(\\\"[data-cy=click-container]\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  // children accessors, don't have to be data-cy\\n  cy.dataCy(\\\"click-container\\\", \\\"[data-cy=count]\\\").should(\\\"contain\\\", 0);\\n  // arbitrarily trying the unlikely approach to dataCy\\n  cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n    cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n  );\\n};\\n\\nDataCy.parameters = {\\n  cyUnitTest: true,\\n  docs: {\\n    description: {\\n      story: dedent`\\n        \\\\`dataCy\\\\` is used to access components by their data-cy designation'.\\n        This file is mostly just for test purposes.\\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\\n        for more detail \\n      `,\\n    },\\n  },\\n};\\n\",\"locationsMap\":{\"data-cy\":{\"startLoc\":{\"col\":59,\"line\":10},\"endLoc\":{\"col\":1,\"line\":12},\"startBody\":{\"col\":59,\"line\":10},\"endBody\":{\"col\":1,\"line\":12}}}},},\n  component: ClickCount,\n};\n\nexport const DataCy: ComponentStoryCy<typeof ClickCount> = (args) => (\n  <ClickCount {...args} />\n);\nDataCy.cy = () => {\n  cy.dataCy(\"count\").should(\"contain\", 0);\n  // nesting data-cy\n  cy.dataCy(\"click-container\").dataCy(\"count\").should(\"contain\", 0);\n  cy.get(\"[data-cy=click-container]\").dataCy(\"count\").should(\"contain\", 0);\n  // children accessors, don't have to be data-cy\n  cy.dataCy(\"click-container\", \"[data-cy=count]\").should(\"contain\", 0);\n  // arbitrarily trying the unlikely approach to dataCy\n  cy.dataCy(\"click-container\").then(($clickContainer) =>\n    cy.dataCy($clickContainer, \"count\").should(\"contain\", 0)\n  );\n};\n\nDataCy.parameters = {\n  cyUnitTest: true,\n  docs: {\n    description: {\n      story: dedent`\n        \\`dataCy\\` is used to access components by their data-cy designation'.\n        This file is mostly just for test purposes.\n        See [module docs](https://quotapath.github.io/orphic-cypress/orphic-cypress/docs/functions/cypress.dataCy-1.html)\n        for more detail \n      `,\n    },\n  },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cy: () => {\\\\n    beforeEach(() => {\\\\n      // just something simple to prove this happens at top\\\\n      cy.wrap(\\\\\\\"DefaultCyProperty label\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n    });\\\\n  },\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"DefaultCyProperty label\\\\\\\" />\\\\n);\\\\n\\\\nDefaultCyProperty.cy = () => {\\\\n  cy.get(\\\\\\\"@wrappedLabel\\\\\\\").then((wrappedLabel) =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", wrappedLabel)\\\\n  );\\\\n  cy.wrap(\\\\\\\"This will be reset\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n};\\\\n// story-code @end @include-default\\\\n\\\\nDefaultCyProperty.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nYou can use default export's \\\\\\\\`cy\\\\\\\\` property to do things like execute\\\\nhooks such as \\\\\\\\`beforeEach\\\\\\\\` to establish test state.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\n\\\\nCyTestFunctionBody.cyTest = (Story) => {\\\\n  beforeEach(() => {\\\\n    cy.wrap(\\\\\\\"Before Wrapped label\\\\\\\").as(\\\\\\\"beforeWrappedLabel\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from default export beforeEach setup\\\\\\\", function () {\\\\n    // function keyword + this instead of .get(\\\\\\\"@alias\\\\\\\") just to show variant\\\\n    cy.mount(<Story label={this.wrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.wrappedLabel);\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from beforeEach in local cyTest\\\\\\\", function () {\\\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.beforeWrappedLabel);\\\\n  });\\\\n};\\\\n// story-code @end\\\\n\\\\nCyTestFunctionBody.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"DefaultCyProperty\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":20},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":20}},\\\"CyTestFunctionBody\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":42},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":42}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cy: () => {\\\\n    beforeEach(() => {\\\\n      // just something simple to prove this happens at top\\\\n      cy.wrap(\\\\\\\"DefaultCyProperty label\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n    });\\\\n  },\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"DefaultCyProperty label\\\\\\\" />\\\\n);\\\\n\\\\nDefaultCyProperty.cy = () => {\\\\n  cy.get(\\\\\\\"@wrappedLabel\\\\\\\").then((wrappedLabel) =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", wrappedLabel)\\\\n  );\\\\n  cy.wrap(\\\\\\\"This will be reset\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n};\\\\n// story-code @end @include-default\\\\n\\\\nDefaultCyProperty.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nYou can use default export's \\\\\\\\`cy\\\\\\\\` property to do things like execute\\\\nhooks such as \\\\\\\\`beforeEach\\\\\\\\` to establish test state.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\n\\\\nCyTestFunctionBody.cyTest = (Story) => {\\\\n  beforeEach(() => {\\\\n    cy.wrap(\\\\\\\"Before Wrapped label\\\\\\\").as(\\\\\\\"beforeWrappedLabel\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from default export beforeEach setup\\\\\\\", function () {\\\\n    // function keyword + this instead of .get(\\\\\\\"@alias\\\\\\\") just to show variant\\\\n    cy.mount(<Story label={this.wrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.wrappedLabel);\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from beforeEach in local cyTest\\\\\\\", function () {\\\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.beforeWrappedLabel);\\\\n  });\\\\n};\\\\n// story-code @end\\\\n\\\\nCyTestFunctionBody.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"default-cy-property\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":20},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":20}},\\\"cy-test-function-body\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":42},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":42}}}},},\\n  component: Button,\\n  cy: () => {\\n    beforeEach(() => {\\n      // just something simple to prove this happens at top\\n      cy.wrap(\\\"DefaultCyProperty label\\\").as(\\\"wrappedLabel\\\");\\n    });\\n  },\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"DefaultCyProperty label\\\" />\\n);;\\n\\nDefaultCyProperty.cy = () => {\\n  cy.get(\\\"@wrappedLabel\\\").then((wrappedLabel) =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", wrappedLabel)\\n  );\\n  cy.wrap(\\\"This will be reset\\\").as(\\\"wrappedLabel\\\");\\n};\\n// story-code @end @include-default\\n\\nDefaultCyProperty.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nYou can use default export's \\\\`cy\\\\` property to do things like execute\\nhooks such as \\\\`beforeEach\\\\` to establish test state.`,\\n    },\\n  },\\n};\\n\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\n\\nCyTestFunctionBody.cyTest = (Story) => {\\n  beforeEach(() => {\\n    cy.wrap(\\\"Before Wrapped label\\\").as(\\\"beforeWrappedLabel\\\");\\n  });\\n\\n  it(\\\"should get label arg from default export beforeEach setup\\\", function () {\\n    // function keyword + this instead of .get(\\\"@alias\\\") just to show variant\\n    cy.mount(<Story label={this.wrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.wrappedLabel);\\n  });\\n\\n  it(\\\"should get label arg from beforeEach in local cyTest\\\", function () {\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.beforeWrappedLabel);\\n  });\\n};\\n// story-code @end\\n\\nCyTestFunctionBody.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\n    },\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"DefaultCyProperty\":{\"startLoc\":{\"col\":66,\"line\":26},\"endLoc\":{\"col\":1,\"line\":28},\"startBody\":{\"col\":66,\"line\":26},\"endBody\":{\"col\":1,\"line\":28}},\"CyTestFunctionBody\":{\"startLoc\":{\"col\":67,\"line\":48},\"endLoc\":{\"col\":1,\"line\":50},\"startBody\":{\"col\":67,\"line\":48},\"endBody\":{\"col\":1,\"line\":50}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {\\n  component: Button,\\n  cy: () => {\\n    beforeEach(() => {\\n      // just something simple to prove this happens at top\\n      cy.wrap(\\\"DefaultCyProperty label\\\").as(\\\"wrappedLabel\\\");\\n    });\\n  },\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"DefaultCyProperty label\\\" />\\n);\\n\\nDefaultCyProperty.cy = () => {\\n  cy.get(\\\"@wrappedLabel\\\").then((wrappedLabel) =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", wrappedLabel)\\n  );\\n  cy.wrap(\\\"This will be reset\\\").as(\\\"wrappedLabel\\\");\\n};\\n// story-code @end @include-default\\n\\nDefaultCyProperty.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nYou can use default export's \\\\`cy\\\\` property to do things like execute\\nhooks such as \\\\`beforeEach\\\\` to establish test state.`,\\n    },\\n  },\\n};\\n\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\n\\nCyTestFunctionBody.cyTest = (Story) => {\\n  beforeEach(() => {\\n    cy.wrap(\\\"Before Wrapped label\\\").as(\\\"beforeWrappedLabel\\\");\\n  });\\n\\n  it(\\\"should get label arg from default export beforeEach setup\\\", function () {\\n    // function keyword + this instead of .get(\\\"@alias\\\") just to show variant\\n    cy.mount(<Story label={this.wrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.wrappedLabel);\\n  });\\n\\n  it(\\\"should get label arg from beforeEach in local cyTest\\\", function () {\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.beforeWrappedLabel);\\n  });\\n};\\n// story-code @end\\n\\nCyTestFunctionBody.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\n    },\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"DefaultCyProperty\":{\"startLoc\":{\"col\":66,\"line\":18},\"endLoc\":{\"col\":1,\"line\":20},\"startBody\":{\"col\":66,\"line\":18},\"endBody\":{\"col\":1,\"line\":20}},\"CyTestFunctionBody\":{\"startLoc\":{\"col\":67,\"line\":40},\"endLoc\":{\"col\":1,\"line\":42},\"startBody\":{\"col\":67,\"line\":40},\"endBody\":{\"col\":1,\"line\":42}}};\n    \nimport React from \"react\";\nimport type { ComponentStoryCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cy: () => {\\\\n    beforeEach(() => {\\\\n      // just something simple to prove this happens at top\\\\n      cy.wrap(\\\\\\\"DefaultCyProperty label\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n    });\\\\n  },\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"DefaultCyProperty label\\\\\\\" />\\\\n);\\\\n\\\\nDefaultCyProperty.cy = () => {\\\\n  cy.get(\\\\\\\"@wrappedLabel\\\\\\\").then((wrappedLabel) =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", wrappedLabel)\\\\n  );\\\\n  cy.wrap(\\\\\\\"This will be reset\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n};\\\\n// story-code @end @include-default\\\\n\\\\nDefaultCyProperty.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nYou can use default export's \\\\\\\\`cy\\\\\\\\` property to do things like execute\\\\nhooks such as \\\\\\\\`beforeEach\\\\\\\\` to establish test state.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\n\\\\nCyTestFunctionBody.cyTest = (Story) => {\\\\n  beforeEach(() => {\\\\n    cy.wrap(\\\\\\\"Before Wrapped label\\\\\\\").as(\\\\\\\"beforeWrappedLabel\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from default export beforeEach setup\\\\\\\", function () {\\\\n    // function keyword + this instead of .get(\\\\\\\"@alias\\\\\\\") just to show variant\\\\n    cy.mount(<Story label={this.wrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.wrappedLabel);\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from beforeEach in local cyTest\\\\\\\", function () {\\\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.beforeWrappedLabel);\\\\n  });\\\\n};\\\\n// story-code @end\\\\n\\\\nCyTestFunctionBody.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"DefaultCyProperty\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":20},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":20}},\\\"CyTestFunctionBody\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":42},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":42}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cy: () => {\\\\n    beforeEach(() => {\\\\n      // just something simple to prove this happens at top\\\\n      cy.wrap(\\\\\\\"DefaultCyProperty label\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n    });\\\\n  },\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"DefaultCyProperty label\\\\\\\" />\\\\n);\\\\n\\\\nDefaultCyProperty.cy = () => {\\\\n  cy.get(\\\\\\\"@wrappedLabel\\\\\\\").then((wrappedLabel) =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", wrappedLabel)\\\\n  );\\\\n  cy.wrap(\\\\\\\"This will be reset\\\\\\\").as(\\\\\\\"wrappedLabel\\\\\\\");\\\\n};\\\\n// story-code @end @include-default\\\\n\\\\nDefaultCyProperty.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nYou can use default export's \\\\\\\\`cy\\\\\\\\` property to do things like execute\\\\nhooks such as \\\\\\\\`beforeEach\\\\\\\\` to establish test state.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\n\\\\nCyTestFunctionBody.cyTest = (Story) => {\\\\n  beforeEach(() => {\\\\n    cy.wrap(\\\\\\\"Before Wrapped label\\\\\\\").as(\\\\\\\"beforeWrappedLabel\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from default export beforeEach setup\\\\\\\", function () {\\\\n    // function keyword + this instead of .get(\\\\\\\"@alias\\\\\\\") just to show variant\\\\n    cy.mount(<Story label={this.wrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.wrappedLabel);\\\\n  });\\\\n\\\\n  it(\\\\\\\"should get label arg from beforeEach in local cyTest\\\\\\\", function () {\\\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", this.beforeWrappedLabel);\\\\n  });\\\\n};\\\\n// story-code @end\\\\n\\\\nCyTestFunctionBody.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"default-cy-property\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":20},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":18},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":20}},\\\"cy-test-function-body\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":42},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":40},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":42}}}},},\\n  component: Button,\\n  cy: () => {\\n    beforeEach(() => {\\n      // just something simple to prove this happens at top\\n      cy.wrap(\\\"DefaultCyProperty label\\\").as(\\\"wrappedLabel\\\");\\n    });\\n  },\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"DefaultCyProperty label\\\" />\\n);;\\n\\nDefaultCyProperty.cy = () => {\\n  cy.get(\\\"@wrappedLabel\\\").then((wrappedLabel) =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", wrappedLabel)\\n  );\\n  cy.wrap(\\\"This will be reset\\\").as(\\\"wrappedLabel\\\");\\n};\\n// story-code @end @include-default\\n\\nDefaultCyProperty.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nYou can use default export's \\\\`cy\\\\` property to do things like execute\\nhooks such as \\\\`beforeEach\\\\` to establish test state.`,\\n    },\\n  },\\n};\\n\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\n\\nCyTestFunctionBody.cyTest = (Story) => {\\n  beforeEach(() => {\\n    cy.wrap(\\\"Before Wrapped label\\\").as(\\\"beforeWrappedLabel\\\");\\n  });\\n\\n  it(\\\"should get label arg from default export beforeEach setup\\\", function () {\\n    // function keyword + this instead of .get(\\\"@alias\\\") just to show variant\\n    cy.mount(<Story label={this.wrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.wrappedLabel);\\n  });\\n\\n  it(\\\"should get label arg from beforeEach in local cyTest\\\", function () {\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.beforeWrappedLabel);\\n  });\\n};\\n// story-code @end\\n\\nCyTestFunctionBody.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\n    },\\n  },\\n};\\n\",\"locationsMap\":{\"default-cy-property\":{\"startLoc\":{\"col\":66,\"line\":26},\"endLoc\":{\"col\":1,\"line\":28},\"startBody\":{\"col\":66,\"line\":26},\"endBody\":{\"col\":1,\"line\":28}},\"cy-test-function-body\":{\"startLoc\":{\"col\":67,\"line\":48},\"endLoc\":{\"col\":1,\"line\":50},\"startBody\":{\"col\":67,\"line\":48},\"endBody\":{\"col\":1,\"line\":50}}}},\"storySource\":{\"source\":\"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {\\n  component: Button,\\n  cy: () => {\\n    beforeEach(() => {\\n      // just something simple to prove this happens at top\\n      cy.wrap(\\\"DefaultCyProperty label\\\").as(\\\"wrappedLabel\\\");\\n    });\\n  },\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"DefaultCyProperty label\\\" />\\n);\\n\\nDefaultCyProperty.cy = () => {\\n  cy.get(\\\"@wrappedLabel\\\").then((wrappedLabel) =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", wrappedLabel)\\n  );\\n  cy.wrap(\\\"This will be reset\\\").as(\\\"wrappedLabel\\\");\\n};\\n// story-code @end @include-default\\n\\nDefaultCyProperty.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nYou can use default export's \\\\`cy\\\\` property to do things like execute\\nhooks such as \\\\`beforeEach\\\\` to establish test state.`,\\n    },\\n  },\\n};\\n\\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\n\\nCyTestFunctionBody.cyTest = (Story) => {\\n  beforeEach(() => {\\n    cy.wrap(\\\"Before Wrapped label\\\").as(\\\"beforeWrappedLabel\\\");\\n  });\\n\\n  it(\\\"should get label arg from default export beforeEach setup\\\", function () {\\n    // function keyword + this instead of .get(\\\"@alias\\\") just to show variant\\n    cy.mount(<Story label={this.wrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.wrappedLabel);\\n  });\\n\\n  it(\\\"should get label arg from beforeEach in local cyTest\\\", function () {\\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", this.beforeWrappedLabel);\\n  });\\n};\\n// story-code @end\\n\\nCyTestFunctionBody.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\\nwhich is the only way to have such hooks execute for only specific story tests.`,\\n    },\\n  },\\n};\\n\",\"locationsMap\":{\"default-cy-property\":{\"startLoc\":{\"col\":66,\"line\":18},\"endLoc\":{\"col\":1,\"line\":20},\"startBody\":{\"col\":66,\"line\":18},\"endBody\":{\"col\":1,\"line\":20}},\"cy-test-function-body\":{\"startLoc\":{\"col\":67,\"line\":40},\"endLoc\":{\"col\":1,\"line\":42},\"startBody\":{\"col\":67,\"line\":40},\"endBody\":{\"col\":1,\"line\":42}}}},},\n  component: Button,\n  cy: () => {\n    beforeEach(() => {\n      // just something simple to prove this happens at top\n      cy.wrap(\"DefaultCyProperty label\").as(\"wrappedLabel\");\n    });\n  },\n};\n\n// These are more repetitive than necessary, real story scenarios would use a 'render'\n// prop to the default export, use object syntax throughout, build a template, etc.\n\nexport const DefaultCyProperty: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"DefaultCyProperty label\" />\n);;;\n\nDefaultCyProperty.cy = () => {\n  cy.get(\"@wrappedLabel\").then((wrappedLabel) =>\n    cy.dataCy(\"button\").should(\"contain\", wrappedLabel)\n  );\n  cy.wrap(\"This will be reset\").as(\"wrappedLabel\");\n};\n// story-code @end @include-default\n\nDefaultCyProperty.parameters = {\n  docs: {\n    description: {\n      story: `\nYou can use default export's \\`cy\\` property to do things like execute\nhooks such as \\`beforeEach\\` to establish test state.`,\n    },\n  },\n};\n\nexport const CyTestFunctionBody: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} />\n);\n\nCyTestFunctionBody.cyTest = (Story) => {\n  beforeEach(() => {\n    cy.wrap(\"Before Wrapped label\").as(\"beforeWrappedLabel\");\n  });\n\n  it(\"should get label arg from default export beforeEach setup\", function () {\n    // function keyword + this instead of .get(\"@alias\") just to show variant\n    cy.mount(<Story label={this.wrappedLabel} />);\n    cy.dataCy(\"button\").should(\"contain\", this.wrappedLabel);\n  });\n\n  it(\"should get label arg from beforeEach in local cyTest\", function () {\n    cy.mount(<Story label={this.beforeWrappedLabel} />);\n    cy.dataCy(\"button\").should(\"contain\", this.beforeWrappedLabel);\n  });\n};\n// story-code @end\n\nCyTestFunctionBody.parameters = {\n  docs: {\n    description: {\n      story: `\nThe .cyTest format can contain hooks like beforeEach directly inside its function body,\nwhich is the only way to have such hooks execute for only specific story tests.`,\n    },\n  },\n};\n","import type { ComponentStory } from \"@storybook/react\";\nimport * as React from \"react\";\nimport { Button } from \"stories\";\n\n// eslint-disable-next-line storybook/story-exports\nexport default {\n  component: Button,\n  // otherwise this would do a mount test like Untested.stories.tsx\n  // which would be fine in this case, just redundant\n  cyIncludeStories: [],\n  // mdx generated docs\n  includeStories: [],\n};\n\nexport const ExternalTest: ComponentStory<typeof Button> = (args) => (\n  <Button {...args} />\n);\nExternalTest.args = { label: \"Will be tested in external .cy file\" };\n// don't show the component in the docs created by mdx\nExternalTest.parameters = {\n  docs: { disable: true },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\nShouldMount.args = { label: \\\\\\\"No cypress tests here\\\\\\\" };\\\\n// story-code @end @include-start\\\\nShouldMount.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"Simply check if the component renders okay without extra cypress assertions\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"ShouldMount\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}}};\\n    \\nimport type { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\nShouldMount.args = { label: \\\\\\\"No cypress tests here\\\\\\\" };\\\\n// story-code @end @include-start\\\\nShouldMount.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"Simply check if the component renders okay without extra cypress assertions\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"should-mount\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}}}},}, component: Button };\\n\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\nShouldMount.args = { label: \\\"No cypress tests here\\\" };\\n// story-code @end @include-start\\nShouldMount.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"Simply check if the component renders okay without extra cypress assertions\\\",\\n    },\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"ShouldMount\":{\"startLoc\":{\"col\":58,\"line\":15},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":58,\"line\":15},\"endBody\":{\"col\":1,\"line\":17}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import type { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button };\\n\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\nShouldMount.args = { label: \\\"No cypress tests here\\\" };\\n// story-code @end @include-start\\nShouldMount.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"Simply check if the component renders okay without extra cypress assertions\\\",\\n    },\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"ShouldMount\":{\"startLoc\":{\"col\":58,\"line\":7},\"endLoc\":{\"col\":1,\"line\":9},\"startBody\":{\"col\":58,\"line\":7},\"endBody\":{\"col\":1,\"line\":9}}};\n    \nimport type { ComponentStory } from \"@storybook/react\";\nimport React from \"react\";\nimport { Button } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\nShouldMount.args = { label: \\\\\\\"No cypress tests here\\\\\\\" };\\\\n// story-code @end @include-start\\\\nShouldMount.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"Simply check if the component renders okay without extra cypress assertions\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"ShouldMount\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}}};\\n    \\nimport type { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\\\n  <Button {...args} />\\\\n);\\\\nShouldMount.args = { label: \\\\\\\"No cypress tests here\\\\\\\" };\\\\n// story-code @end @include-start\\\\nShouldMount.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"Simply check if the component renders okay without extra cypress assertions\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"should-mount\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}}}},}, component: Button };\\n\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\nShouldMount.args = { label: \\\"No cypress tests here\\\" };\\n// story-code @end @include-start\\nShouldMount.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"Simply check if the component renders okay without extra cypress assertions\\\",\\n    },\\n  },\\n};\\n\",\"locationsMap\":{\"should-mount\":{\"startLoc\":{\"col\":58,\"line\":15},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":58,\"line\":15},\"endBody\":{\"col\":1,\"line\":17}}}},\"storySource\":{\"source\":\"import type { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button };\\n\\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\\n  <Button {...args} />\\n);\\nShouldMount.args = { label: \\\"No cypress tests here\\\" };\\n// story-code @end @include-start\\nShouldMount.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"Simply check if the component renders okay without extra cypress assertions\\\",\\n    },\\n  },\\n};\\n\",\"locationsMap\":{\"should-mount\":{\"startLoc\":{\"col\":58,\"line\":7},\"endLoc\":{\"col\":1,\"line\":9},\"startBody\":{\"col\":58,\"line\":7},\"endBody\":{\"col\":1,\"line\":9}}}},}, component: Button };\n\nexport const ShouldMount: ComponentStory<typeof Button> = (args) => (\n  <Button {...args} />\n);\nShouldMount.args = { label: \"No cypress tests here\" };\n// story-code @end @include-start\nShouldMount.parameters = {\n  docs: {\n    description: {\n      story:\n        \"Simply check if the component renders okay without extra cypress assertions\",\n    },\n  },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  id: \\\\\\\"fileformats-storybookfiles\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story function\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nStoryFunctionWithCyFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\".cy is the simplest format, expecting just a function which executes in cypress\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\nStoryFunctionWithCyObject.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\\\\\`it\\\\\\\\`'s\\\\nand the bodies execute within their own tests.\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n\\\\nbecomes\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\ndescribe(\\\\\\\"Story Function With Cy Object\\\\\\\", () => {\\\\n  it(\\\\\\\"should contain 'Story object' label\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\")\\\\n  );\\\\n\\\\n  it(\\\\\\\"should not be disabled by default\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\")\\\\n  );\\\\n});\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n`,\\\\n    },\\\\n    source: { code: null },\\\\n  },\\\\n};\\\\n\\\\n// Could accept args, but label is required, so just showing a non-args version\\\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button label=\\\\\\\"Story test\\\\\\\" {...args} />;\\\\n\\\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\\\n  it(\\\\\\\"should contain 'Story test' label\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story test\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should accept a disabled prop\\\\\\\", () => {\\\\n    cy.mount(<Story disabled />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"be.disabled\\\\\\\");\\\\n  });\\\\n\\\\n  /* istanbul ignore next */ // story-code @skip\\\\n  it.skip(\\\\\\\"should skip a test\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\n      \\\\\\\"contain\\\\\\\",\\\\n      \\\\\\\"This test would fail if not skipped\\\\\\\"\\\\n    );\\\\n  });\\\\n};\\\\n// story-code @end\\\\nStoryFunctionWithCyTest.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cyTest offers the most control and is the most verbose.\\\\nIt allows executing test hooks like beforeEach, calling it.skip,\\\\nor passing new arguments to the story at each test, but requires\\\\nmanually calling cy.mount on the component that comes in as an argument.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\\\n  args: { label: \\\\\\\"Story function\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\"),\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\\\nstory format. Together, they can make for some truly small but powerful tests.`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\\\n  <Button label=\\\\\\\"Parameters\\\\\\\" {...args} />\\\\n);\\\\nParametersWithCyTests.parameters = {\\\\n  // cyTest, cySkip, cyOnly also available here\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Parameters\\\\\\\"),\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nAnything defined against the story or the default export can also be put in\\\\n'parameters' which may be more canonical but adds a decent amount of characters\\\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\\\n    },\\\\n  },\\\\n};\\\\n// story-code @end\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"StoryFunctionWithCyFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endLoc\\\":{\\\"col\\\":48,\\\"line\\\":16},\\\"startBody\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endBody\\\":{\\\"col\\\":48,\\\"line\\\":16}},\\\"StoryFunctionWithCyObject\\\":{\\\"startLoc\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endLoc\\\":{\\\"col\\\":46,\\\"line\\\":32},\\\"startBody\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endBody\\\":{\\\"col\\\":46,\\\"line\\\":32}},\\\"StoryFunctionWithCyTest\\\":{\\\"startLoc\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endLoc\\\":{\\\"col\\\":44,\\\"line\\\":85},\\\"startBody\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endBody\\\":{\\\"col\\\":44,\\\"line\\\":85}},\\\"ParametersWithCyTests\\\":{\\\"startLoc\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":138},\\\"startBody\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":138}}};\\n    \\nimport { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  id: \\\\\\\"fileformats-storybookfiles\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story function\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nStoryFunctionWithCyFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\".cy is the simplest format, expecting just a function which executes in cypress\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\nStoryFunctionWithCyObject.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\\\\\`it\\\\\\\\`'s\\\\nand the bodies execute within their own tests.\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n\\\\nbecomes\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\ndescribe(\\\\\\\"Story Function With Cy Object\\\\\\\", () => {\\\\n  it(\\\\\\\"should contain 'Story object' label\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\")\\\\n  );\\\\n\\\\n  it(\\\\\\\"should not be disabled by default\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\")\\\\n  );\\\\n});\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n`,\\\\n    },\\\\n    source: { code: null },\\\\n  },\\\\n};\\\\n\\\\n// Could accept args, but label is required, so just showing a non-args version\\\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button label=\\\\\\\"Story test\\\\\\\" {...args} />;\\\\n\\\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\\\n  it(\\\\\\\"should contain 'Story test' label\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story test\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should accept a disabled prop\\\\\\\", () => {\\\\n    cy.mount(<Story disabled />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"be.disabled\\\\\\\");\\\\n  });\\\\n\\\\n  /* istanbul ignore next */ // story-code @skip\\\\n  it.skip(\\\\\\\"should skip a test\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\n      \\\\\\\"contain\\\\\\\",\\\\n      \\\\\\\"This test would fail if not skipped\\\\\\\"\\\\n    );\\\\n  });\\\\n};\\\\n// story-code @end\\\\nStoryFunctionWithCyTest.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cyTest offers the most control and is the most verbose.\\\\nIt allows executing test hooks like beforeEach, calling it.skip,\\\\nor passing new arguments to the story at each test, but requires\\\\nmanually calling cy.mount on the component that comes in as an argument.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\\\n  args: { label: \\\\\\\"Story function\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\"),\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\\\nstory format. Together, they can make for some truly small but powerful tests.`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\\\n  <Button label=\\\\\\\"Parameters\\\\\\\" {...args} />\\\\n);\\\\nParametersWithCyTests.parameters = {\\\\n  // cyTest, cySkip, cyOnly also available here\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Parameters\\\\\\\"),\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nAnything defined against the story or the default export can also be put in\\\\n'parameters' which may be more canonical but adds a decent amount of characters\\\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\\\n    },\\\\n  },\\\\n};\\\\n// story-code @end\\\\n\\\",\\\"locationsMap\\\":{\\\"story-function-with-cy-function\\\":{\\\"startLoc\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endLoc\\\":{\\\"col\\\":48,\\\"line\\\":16},\\\"startBody\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endBody\\\":{\\\"col\\\":48,\\\"line\\\":16}},\\\"story-function-with-cy-object\\\":{\\\"startLoc\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endLoc\\\":{\\\"col\\\":46,\\\"line\\\":32},\\\"startBody\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endBody\\\":{\\\"col\\\":46,\\\"line\\\":32}},\\\"story-function-with-cy-test\\\":{\\\"startLoc\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endLoc\\\":{\\\"col\\\":44,\\\"line\\\":85},\\\"startBody\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endBody\\\":{\\\"col\\\":44,\\\"line\\\":85}},\\\"parameters-with-cy-tests\\\":{\\\"startLoc\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":138},\\\"startBody\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":138}}}},},\\n  component: Button,\\n  id: \\\"fileformats-storybookfiles\\\", // story-code @skip\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story function\\\" />;;\\n\\nStoryFunctionWithCyFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nStoryFunctionWithCyFunction.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\".cy is the simplest format, expecting just a function which executes in cypress\\\",\\n    },\\n  },\\n};\\n\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\nStoryFunctionWithCyObject.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\`it\\\\`'s\\nand the bodies execute within their own tests.\\n\\n\\\\`\\\\`\\\\`tsx\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\\\`\\\\`\\\\`\\n\\nbecomes\\n\\n\\\\`\\\\`\\\\`tsx\\ndescribe(\\\"Story Function With Cy Object\\\", () => {\\n  it(\\\"should contain 'Story object' label\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\")\\n  );\\n\\n  it(\\\"should not be disabled by default\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\")\\n  );\\n});\\n\\\\`\\\\`\\\\`\\n`,\\n    },\\n    source: { code: null },\\n  },\\n};\\n\\n// Could accept args, but label is required, so just showing a non-args version\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button label=\\\"Story test\\\" {...args} />;;\\n\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\n  it(\\\"should contain 'Story test' label\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story test\\\");\\n  });\\n\\n  it(\\\"should accept a disabled prop\\\", () => {\\n    cy.mount(<Story disabled />);\\n    cy.dataCy(\\\"button\\\").should(\\\"be.disabled\\\");\\n  });\\n\\n  /* istanbul ignore next */ // story-code @skip\\n  it.skip(\\\"should skip a test\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\n      \\\"contain\\\",\\n      \\\"This test would fail if not skipped\\\"\\n    );\\n  });\\n};\\n// story-code @end\\nStoryFunctionWithCyTest.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cyTest offers the most control and is the most verbose.\\nIt allows executing test hooks like beforeEach, calling it.skip,\\nor passing new arguments to the story at each test, but requires\\nmanually calling cy.mount on the component that comes in as an argument.`,\\n    },\\n  },\\n};\\n\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\n  args: { label: \\\"Story function\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\"),\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\nstory format. Together, they can make for some truly small but powerful tests.`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\n  <Button label=\\\"Parameters\\\" {...args} />\\n);\\nParametersWithCyTests.parameters = {\\n  // cyTest, cySkip, cyOnly also available here\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Parameters\\\"),\\n  docs: {\\n    description: {\\n      story: `\\nAnything defined against the story or the default export can also be put in\\n'parameters' which may be more canonical but adds a decent amount of characters\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\n    },\\n  },\\n};\\n// story-code @end\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"StoryFunctionWithCyFunction\":{\"startLoc\":{\"col\":76,\"line\":22},\"endLoc\":{\"col\":48,\"line\":24},\"startBody\":{\"col\":76,\"line\":22},\"endBody\":{\"col\":48,\"line\":24}},\"StoryFunctionWithCyObject\":{\"startLoc\":{\"col\":74,\"line\":38},\"endLoc\":{\"col\":46,\"line\":40},\"startBody\":{\"col\":74,\"line\":38},\"endBody\":{\"col\":46,\"line\":40}},\"StoryFunctionWithCyTest\":{\"startLoc\":{\"col\":72,\"line\":91},\"endLoc\":{\"col\":44,\"line\":93},\"startBody\":{\"col\":72,\"line\":91},\"endBody\":{\"col\":44,\"line\":93}},\"ParametersWithCyTests\":{\"startLoc\":{\"col\":68,\"line\":144},\"endLoc\":{\"col\":1,\"line\":146},\"startBody\":{\"col\":68,\"line\":144},\"endBody\":{\"col\":1,\"line\":146}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {\\n  component: Button,\\n  id: \\\"fileformats-storybookfiles\\\", // story-code @skip\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story function\\\" />;\\n\\nStoryFunctionWithCyFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nStoryFunctionWithCyFunction.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\".cy is the simplest format, expecting just a function which executes in cypress\\\",\\n    },\\n  },\\n};\\n\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\nStoryFunctionWithCyObject.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\`it\\\\`'s\\nand the bodies execute within their own tests.\\n\\n\\\\`\\\\`\\\\`tsx\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\\\`\\\\`\\\\`\\n\\nbecomes\\n\\n\\\\`\\\\`\\\\`tsx\\ndescribe(\\\"Story Function With Cy Object\\\", () => {\\n  it(\\\"should contain 'Story object' label\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\")\\n  );\\n\\n  it(\\\"should not be disabled by default\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\")\\n  );\\n});\\n\\\\`\\\\`\\\\`\\n`,\\n    },\\n    source: { code: null },\\n  },\\n};\\n\\n// Could accept args, but label is required, so just showing a non-args version\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button label=\\\"Story test\\\" {...args} />;\\n\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\n  it(\\\"should contain 'Story test' label\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story test\\\");\\n  });\\n\\n  it(\\\"should accept a disabled prop\\\", () => {\\n    cy.mount(<Story disabled />);\\n    cy.dataCy(\\\"button\\\").should(\\\"be.disabled\\\");\\n  });\\n\\n  /* istanbul ignore next */ // story-code @skip\\n  it.skip(\\\"should skip a test\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\n      \\\"contain\\\",\\n      \\\"This test would fail if not skipped\\\"\\n    );\\n  });\\n};\\n// story-code @end\\nStoryFunctionWithCyTest.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cyTest offers the most control and is the most verbose.\\nIt allows executing test hooks like beforeEach, calling it.skip,\\nor passing new arguments to the story at each test, but requires\\nmanually calling cy.mount on the component that comes in as an argument.`,\\n    },\\n  },\\n};\\n\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\n  args: { label: \\\"Story function\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\"),\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\nstory format. Together, they can make for some truly small but powerful tests.`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\n  <Button label=\\\"Parameters\\\" {...args} />\\n);\\nParametersWithCyTests.parameters = {\\n  // cyTest, cySkip, cyOnly also available here\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Parameters\\\"),\\n  docs: {\\n    description: {\\n      story: `\\nAnything defined against the story or the default export can also be put in\\n'parameters' which may be more canonical but adds a decent amount of characters\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\n    },\\n  },\\n};\\n// story-code @end\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"StoryFunctionWithCyFunction\":{\"startLoc\":{\"col\":76,\"line\":14},\"endLoc\":{\"col\":48,\"line\":16},\"startBody\":{\"col\":76,\"line\":14},\"endBody\":{\"col\":48,\"line\":16}},\"StoryFunctionWithCyObject\":{\"startLoc\":{\"col\":74,\"line\":30},\"endLoc\":{\"col\":46,\"line\":32},\"startBody\":{\"col\":74,\"line\":30},\"endBody\":{\"col\":46,\"line\":32}},\"StoryFunctionWithCyTest\":{\"startLoc\":{\"col\":72,\"line\":83},\"endLoc\":{\"col\":44,\"line\":85},\"startBody\":{\"col\":72,\"line\":83},\"endBody\":{\"col\":44,\"line\":85}},\"ParametersWithCyTests\":{\"startLoc\":{\"col\":68,\"line\":136},\"endLoc\":{\"col\":1,\"line\":138},\"startBody\":{\"col\":68,\"line\":136},\"endBody\":{\"col\":1,\"line\":138}}};\n    \nimport { ComponentStory } from \"@storybook/react\";\nimport React from \"react\";\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  id: \\\\\\\"fileformats-storybookfiles\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story function\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nStoryFunctionWithCyFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\".cy is the simplest format, expecting just a function which executes in cypress\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\nStoryFunctionWithCyObject.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\\\\\`it\\\\\\\\`'s\\\\nand the bodies execute within their own tests.\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n\\\\nbecomes\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\ndescribe(\\\\\\\"Story Function With Cy Object\\\\\\\", () => {\\\\n  it(\\\\\\\"should contain 'Story object' label\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\")\\\\n  );\\\\n\\\\n  it(\\\\\\\"should not be disabled by default\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\")\\\\n  );\\\\n});\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n`,\\\\n    },\\\\n    source: { code: null },\\\\n  },\\\\n};\\\\n\\\\n// Could accept args, but label is required, so just showing a non-args version\\\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button label=\\\\\\\"Story test\\\\\\\" {...args} />;\\\\n\\\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\\\n  it(\\\\\\\"should contain 'Story test' label\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story test\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should accept a disabled prop\\\\\\\", () => {\\\\n    cy.mount(<Story disabled />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"be.disabled\\\\\\\");\\\\n  });\\\\n\\\\n  /* istanbul ignore next */ // story-code @skip\\\\n  it.skip(\\\\\\\"should skip a test\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\n      \\\\\\\"contain\\\\\\\",\\\\n      \\\\\\\"This test would fail if not skipped\\\\\\\"\\\\n    );\\\\n  });\\\\n};\\\\n// story-code @end\\\\nStoryFunctionWithCyTest.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cyTest offers the most control and is the most verbose.\\\\nIt allows executing test hooks like beforeEach, calling it.skip,\\\\nor passing new arguments to the story at each test, but requires\\\\nmanually calling cy.mount on the component that comes in as an argument.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\\\n  args: { label: \\\\\\\"Story function\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\"),\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\\\nstory format. Together, they can make for some truly small but powerful tests.`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\\\n  <Button label=\\\\\\\"Parameters\\\\\\\" {...args} />\\\\n);\\\\nParametersWithCyTests.parameters = {\\\\n  // cyTest, cySkip, cyOnly also available here\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Parameters\\\\\\\"),\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nAnything defined against the story or the default export can also be put in\\\\n'parameters' which may be more canonical but adds a decent amount of characters\\\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\\\n    },\\\\n  },\\\\n};\\\\n// story-code @end\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"StoryFunctionWithCyFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endLoc\\\":{\\\"col\\\":48,\\\"line\\\":16},\\\"startBody\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endBody\\\":{\\\"col\\\":48,\\\"line\\\":16}},\\\"StoryFunctionWithCyObject\\\":{\\\"startLoc\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endLoc\\\":{\\\"col\\\":46,\\\"line\\\":32},\\\"startBody\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endBody\\\":{\\\"col\\\":46,\\\"line\\\":32}},\\\"StoryFunctionWithCyTest\\\":{\\\"startLoc\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endLoc\\\":{\\\"col\\\":44,\\\"line\\\":85},\\\"startBody\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endBody\\\":{\\\"col\\\":44,\\\"line\\\":85}},\\\"ParametersWithCyTests\\\":{\\\"startLoc\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":138},\\\"startBody\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":138}}};\\n    \\nimport { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  id: \\\\\\\"fileformats-storybookfiles\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\\\n// prop to the default export, use object syntax throughout, build a template, etc.\\\\n\\\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story function\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nStoryFunctionWithCyFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\".cy is the simplest format, expecting just a function which executes in cypress\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\nStoryFunctionWithCyObject.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\\\\\`it\\\\\\\\`'s\\\\nand the bodies execute within their own tests.\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} label=\\\\\\\"Story object\\\\\\\" />;\\\\n\\\\nStoryFunctionWithCyObject.cy = {\\\\n  \\\\\\\"should contain 'Story object' label\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\"),\\\\n\\\\n  \\\\\\\"should not be disabled by default\\\\\\\": () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\"),\\\\n};\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n\\\\nbecomes\\\\n\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`tsx\\\\ndescribe(\\\\\\\"Story Function With Cy Object\\\\\\\", () => {\\\\n  it(\\\\\\\"should contain 'Story object' label\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story object\\\\\\\")\\\\n  );\\\\n\\\\n  it(\\\\\\\"should not be disabled by default\\\\\\\", () =>\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"not.be.disabled\\\\\\\")\\\\n  );\\\\n});\\\\n\\\\\\\\`\\\\\\\\`\\\\\\\\`\\\\n`,\\\\n    },\\\\n    source: { code: null },\\\\n  },\\\\n};\\\\n\\\\n// Could accept args, but label is required, so just showing a non-args version\\\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\\\n  args\\\\n) => <Button label=\\\\\\\"Story test\\\\\\\" {...args} />;\\\\n\\\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\\\n  it(\\\\\\\"should contain 'Story test' label\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story test\\\\\\\");\\\\n  });\\\\n\\\\n  it(\\\\\\\"should accept a disabled prop\\\\\\\", () => {\\\\n    cy.mount(<Story disabled />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"be.disabled\\\\\\\");\\\\n  });\\\\n\\\\n  /* istanbul ignore next */ // story-code @skip\\\\n  it.skip(\\\\\\\"should skip a test\\\\\\\", () => {\\\\n    cy.mount(<Story />);\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\n      \\\\\\\"contain\\\\\\\",\\\\n      \\\\\\\"This test would fail if not skipped\\\\\\\"\\\\n    );\\\\n  });\\\\n};\\\\n// story-code @end\\\\nStoryFunctionWithCyTest.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\n.cyTest offers the most control and is the most verbose.\\\\nIt allows executing test hooks like beforeEach, calling it.skip,\\\\nor passing new arguments to the story at each test, but requires\\\\nmanually calling cy.mount on the component that comes in as an argument.`,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\\\n  args: { label: \\\\\\\"Story function\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\"),\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\\\nstory format. Together, they can make for some truly small but powerful tests.`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\\\n  <Button label=\\\\\\\"Parameters\\\\\\\" {...args} />\\\\n);\\\\nParametersWithCyTests.parameters = {\\\\n  // cyTest, cySkip, cyOnly also available here\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Parameters\\\\\\\"),\\\\n  docs: {\\\\n    description: {\\\\n      story: `\\\\nAnything defined against the story or the default export can also be put in\\\\n'parameters' which may be more canonical but adds a decent amount of characters\\\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\\\n    },\\\\n  },\\\\n};\\\\n// story-code @end\\\\n\\\",\\\"locationsMap\\\":{\\\"story-function-with-cy-function\\\":{\\\"startLoc\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endLoc\\\":{\\\"col\\\":48,\\\"line\\\":16},\\\"startBody\\\":{\\\"col\\\":76,\\\"line\\\":14},\\\"endBody\\\":{\\\"col\\\":48,\\\"line\\\":16}},\\\"story-function-with-cy-object\\\":{\\\"startLoc\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endLoc\\\":{\\\"col\\\":46,\\\"line\\\":32},\\\"startBody\\\":{\\\"col\\\":74,\\\"line\\\":30},\\\"endBody\\\":{\\\"col\\\":46,\\\"line\\\":32}},\\\"story-function-with-cy-test\\\":{\\\"startLoc\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endLoc\\\":{\\\"col\\\":44,\\\"line\\\":85},\\\"startBody\\\":{\\\"col\\\":72,\\\"line\\\":83},\\\"endBody\\\":{\\\"col\\\":44,\\\"line\\\":85}},\\\"parameters-with-cy-tests\\\":{\\\"startLoc\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":138},\\\"startBody\\\":{\\\"col\\\":68,\\\"line\\\":136},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":138}}}},},\\n  component: Button,\\n  id: \\\"fileformats-storybookfiles\\\", // story-code @skip\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story function\\\" />;;\\n\\nStoryFunctionWithCyFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nStoryFunctionWithCyFunction.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\".cy is the simplest format, expecting just a function which executes in cypress\\\",\\n    },\\n  },\\n};\\n\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\nStoryFunctionWithCyObject.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\`it\\\\`'s\\nand the bodies execute within their own tests.\\n\\n\\\\`\\\\`\\\\`tsx\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\\\`\\\\`\\\\`\\n\\nbecomes\\n\\n\\\\`\\\\`\\\\`tsx\\ndescribe(\\\"Story Function With Cy Object\\\", () => {\\n  it(\\\"should contain 'Story object' label\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\")\\n  );\\n\\n  it(\\\"should not be disabled by default\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\")\\n  );\\n});\\n\\\\`\\\\`\\\\`\\n`,\\n    },\\n    source: { code: null },\\n  },\\n};\\n\\n// Could accept args, but label is required, so just showing a non-args version\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button label=\\\"Story test\\\" {...args} />;;\\n\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\n  it(\\\"should contain 'Story test' label\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story test\\\");\\n  });\\n\\n  it(\\\"should accept a disabled prop\\\", () => {\\n    cy.mount(<Story disabled />);\\n    cy.dataCy(\\\"button\\\").should(\\\"be.disabled\\\");\\n  });\\n\\n  /* istanbul ignore next */ // story-code @skip\\n  it.skip(\\\"should skip a test\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\n      \\\"contain\\\",\\n      \\\"This test would fail if not skipped\\\"\\n    );\\n  });\\n};\\n// story-code @end\\nStoryFunctionWithCyTest.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cyTest offers the most control and is the most verbose.\\nIt allows executing test hooks like beforeEach, calling it.skip,\\nor passing new arguments to the story at each test, but requires\\nmanually calling cy.mount on the component that comes in as an argument.`,\\n    },\\n  },\\n};\\n\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\n  args: { label: \\\"Story function\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\"),\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\nstory format. Together, they can make for some truly small but powerful tests.`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\n  <Button label=\\\"Parameters\\\" {...args} />\\n);\\nParametersWithCyTests.parameters = {\\n  // cyTest, cySkip, cyOnly also available here\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Parameters\\\"),\\n  docs: {\\n    description: {\\n      story: `\\nAnything defined against the story or the default export can also be put in\\n'parameters' which may be more canonical but adds a decent amount of characters\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\n    },\\n  },\\n};\\n// story-code @end\\n\",\"locationsMap\":{\"story-function-with-cy-function\":{\"startLoc\":{\"col\":76,\"line\":22},\"endLoc\":{\"col\":48,\"line\":24},\"startBody\":{\"col\":76,\"line\":22},\"endBody\":{\"col\":48,\"line\":24}},\"story-function-with-cy-object\":{\"startLoc\":{\"col\":74,\"line\":38},\"endLoc\":{\"col\":46,\"line\":40},\"startBody\":{\"col\":74,\"line\":38},\"endBody\":{\"col\":46,\"line\":40}},\"story-function-with-cy-test\":{\"startLoc\":{\"col\":72,\"line\":91},\"endLoc\":{\"col\":44,\"line\":93},\"startBody\":{\"col\":72,\"line\":91},\"endBody\":{\"col\":44,\"line\":93}},\"parameters-with-cy-tests\":{\"startLoc\":{\"col\":68,\"line\":144},\"endLoc\":{\"col\":1,\"line\":146},\"startBody\":{\"col\":68,\"line\":144},\"endBody\":{\"col\":1,\"line\":146}}}},\"storySource\":{\"source\":\"import { ComponentStory } from \\\"@storybook/react\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {\\n  component: Button,\\n  id: \\\"fileformats-storybookfiles\\\", // story-code @skip\\n};\\n\\n// These are more repetitive than necessary, real story scenarios would use a 'render'\\n// prop to the default export, use object syntax throughout, build a template, etc.\\n\\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story function\\\" />;\\n\\nStoryFunctionWithCyFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nStoryFunctionWithCyFunction.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\".cy is the simplest format, expecting just a function which executes in cypress\\\",\\n    },\\n  },\\n};\\n\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\nStoryFunctionWithCyObject.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cy also allows an object syntax where the text keys become the input for cypress \\\\`it\\\\`'s\\nand the bodies execute within their own tests.\\n\\n\\\\`\\\\`\\\\`tsx\\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button {...args} label=\\\"Story object\\\" />;\\n\\nStoryFunctionWithCyObject.cy = {\\n  \\\"should contain 'Story object' label\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\"),\\n\\n  \\\"should not be disabled by default\\\": () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\"),\\n};\\n\\\\`\\\\`\\\\`\\n\\nbecomes\\n\\n\\\\`\\\\`\\\\`tsx\\ndescribe(\\\"Story Function With Cy Object\\\", () => {\\n  it(\\\"should contain 'Story object' label\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story object\\\")\\n  );\\n\\n  it(\\\"should not be disabled by default\\\", () =>\\n    cy.dataCy(\\\"button\\\").should(\\\"not.be.disabled\\\")\\n  );\\n});\\n\\\\`\\\\`\\\\`\\n`,\\n    },\\n    source: { code: null },\\n  },\\n};\\n\\n// Could accept args, but label is required, so just showing a non-args version\\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\\n  args\\n) => <Button label=\\\"Story test\\\" {...args} />;\\n\\nStoryFunctionWithCyTest.cyTest = (Story) => {\\n  it(\\\"should contain 'Story test' label\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story test\\\");\\n  });\\n\\n  it(\\\"should accept a disabled prop\\\", () => {\\n    cy.mount(<Story disabled />);\\n    cy.dataCy(\\\"button\\\").should(\\\"be.disabled\\\");\\n  });\\n\\n  /* istanbul ignore next */ // story-code @skip\\n  it.skip(\\\"should skip a test\\\", () => {\\n    cy.mount(<Story />);\\n    cy.dataCy(\\\"button\\\").should(\\n      \\\"contain\\\",\\n      \\\"This test would fail if not skipped\\\"\\n    );\\n  });\\n};\\n// story-code @end\\nStoryFunctionWithCyTest.parameters = {\\n  docs: {\\n    description: {\\n      story: `\\n.cyTest offers the most control and is the most verbose.\\nIt allows executing test hooks like beforeEach, calling it.skip,\\nor passing new arguments to the story at each test, but requires\\nmanually calling cy.mount on the component that comes in as an argument.`,\\n    },\\n  },\\n};\\n\\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\\n  args: { label: \\\"Story function\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\"),\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\n.cy is the most concise testing syntax and CSF object syntax is the most concise\\nstory format. Together, they can make for some truly small but powerful tests.`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\\n  <Button label=\\\"Parameters\\\" {...args} />\\n);\\nParametersWithCyTests.parameters = {\\n  // cyTest, cySkip, cyOnly also available here\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Parameters\\\"),\\n  docs: {\\n    description: {\\n      story: `\\nAnything defined against the story or the default export can also be put in\\n'parameters' which may be more canonical but adds a decent amount of characters\\nto the definitions. NOTE: you can use storybook's own ComponentStory or\\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\\n    },\\n  },\\n};\\n// story-code @end\\n\",\"locationsMap\":{\"story-function-with-cy-function\":{\"startLoc\":{\"col\":76,\"line\":14},\"endLoc\":{\"col\":48,\"line\":16},\"startBody\":{\"col\":76,\"line\":14},\"endBody\":{\"col\":48,\"line\":16}},\"story-function-with-cy-object\":{\"startLoc\":{\"col\":74,\"line\":30},\"endLoc\":{\"col\":46,\"line\":32},\"startBody\":{\"col\":74,\"line\":30},\"endBody\":{\"col\":46,\"line\":32}},\"story-function-with-cy-test\":{\"startLoc\":{\"col\":72,\"line\":83},\"endLoc\":{\"col\":44,\"line\":85},\"startBody\":{\"col\":72,\"line\":83},\"endBody\":{\"col\":44,\"line\":85}},\"parameters-with-cy-tests\":{\"startLoc\":{\"col\":68,\"line\":136},\"endLoc\":{\"col\":1,\"line\":138},\"startBody\":{\"col\":68,\"line\":136},\"endBody\":{\"col\":1,\"line\":138}}}},},\n  component: Button,\n  id: \"fileformats-storybookfiles\", // story-code @skip\n};\n\n// These are more repetitive than necessary, real story scenarios would use a 'render'\n// prop to the default export, use object syntax throughout, build a template, etc.\n\nexport const StoryFunctionWithCyFunction: ComponentStoryCy<typeof Button> = (\n  args\n) => <Button {...args} label=\"Story function\" />;;;\n\nStoryFunctionWithCyFunction.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Story function\");\n// story-code @end @include-default\nStoryFunctionWithCyFunction.parameters = {\n  docs: {\n    description: {\n      story:\n        \".cy is the simplest format, expecting just a function which executes in cypress\",\n    },\n  },\n};\n\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\n  args\n) => <Button {...args} label=\"Story object\" />;;;\n\nStoryFunctionWithCyObject.cy = {\n  \"should contain 'Story object' label\": () =>\n    cy.dataCy(\"button\").should(\"contain\", \"Story object\"),\n\n  \"should not be disabled by default\": () =>\n    cy.dataCy(\"button\").should(\"not.be.disabled\"),\n};\n\nStoryFunctionWithCyObject.parameters = {\n  docs: {\n    description: {\n      story: `\n.cy also allows an object syntax where the text keys become the input for cypress \\`it\\`'s\nand the bodies execute within their own tests.\n\n\\`\\`\\`tsx\nexport const StoryFunctionWithCyObject: ComponentStoryCy<typeof Button> = (\n  args\n) => <Button {...args} label=\"Story object\" />;\n\nStoryFunctionWithCyObject.cy = {\n  \"should contain 'Story object' label\": () =>\n    cy.dataCy(\"button\").should(\"contain\", \"Story object\"),\n\n  \"should not be disabled by default\": () =>\n    cy.dataCy(\"button\").should(\"not.be.disabled\"),\n};\n\\`\\`\\`\n\nbecomes\n\n\\`\\`\\`tsx\ndescribe(\"Story Function With Cy Object\", () => {\n  it(\"should contain 'Story object' label\", () =>\n    cy.dataCy(\"button\").should(\"contain\", \"Story object\")\n  );\n\n  it(\"should not be disabled by default\", () =>\n    cy.dataCy(\"button\").should(\"not.be.disabled\")\n  );\n});\n\\`\\`\\`\n`,\n    },\n    source: { code: null },\n  },\n};\n\n// Could accept args, but label is required, so just showing a non-args version\nexport const StoryFunctionWithCyTest: ComponentStoryCy<typeof Button> = (\n  args\n) => <Button label=\"Story test\" {...args} />;;;\n\nStoryFunctionWithCyTest.cyTest = (Story) => {\n  it(\"should contain 'Story test' label\", () => {\n    cy.mount(<Story />);\n    cy.dataCy(\"button\").should(\"contain\", \"Story test\");\n  });\n\n  it(\"should accept a disabled prop\", () => {\n    cy.mount(<Story disabled />);\n    cy.dataCy(\"button\").should(\"be.disabled\");\n  });\n\n  /* istanbul ignore next */ // story-code @skip\n  it.skip(\"should skip a test\", () => {\n    cy.mount(<Story />);\n    cy.dataCy(\"button\").should(\n      \"contain\",\n      \"This test would fail if not skipped\"\n    );\n  });\n};\n// story-code @end\nStoryFunctionWithCyTest.parameters = {\n  docs: {\n    description: {\n      story: `\n.cyTest offers the most control and is the most verbose.\nIt allows executing test hooks like beforeEach, calling it.skip,\nor passing new arguments to the story at each test, but requires\nmanually calling cy.mount on the component that comes in as an argument.`,\n    },\n  },\n};\n\nexport const StoryObjectWithCyFunction: ComponentStoryObjCy<typeof Button> = {\n  args: { label: \"Story function\" },\n  cy: () => cy.dataCy(\"button\").should(\"contain\", \"Story function\"),\n  // story-code @skip-start\n  parameters: {\n    docs: {\n      description: {\n        story: `\n.cy is the most concise testing syntax and CSF object syntax is the most concise\nstory format. Together, they can make for some truly small but powerful tests.`,\n      },\n    },\n  },\n  // story-code @skip-end\n};\n\nexport const ParametersWithCyTests: ComponentStory<typeof Button> = (args) => (\n  <Button label=\"Parameters\" {...args} />\n);\nParametersWithCyTests.parameters = {\n  // cyTest, cySkip, cyOnly also available here\n  cy: () => cy.dataCy(\"button\").should(\"contain\", \"Parameters\"),\n  docs: {\n    description: {\n      story: `\nAnything defined against the story or the default export can also be put in\n'parameters' which may be more canonical but adds a decent amount of characters\nto the definitions. NOTE: you can use storybook's own ComponentStory or\nComponentStoryObj for types, but it'll leave parameters completely untyped.`,\n    },\n  },\n};\n// story-code @end\n","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { Title } from \"stories\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <Title mdxType=\"Title\" />\n    <p>{`You can import mdx files and use them as docs just fine while also having cypress expectations.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import type { ComponentStory } from \"@storybook/react\";\nimport * as React from \"react\";\nimport mdx from \"./index.mdx\";\nimport { Button } from \"stories\";\n\nexport default { component: Button };\n\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\n  args\n) => <Button {...args} />;\nCSFStoriesWithArbitraryMDX.args = {\n  label: \"Documentation provided by arbitrary mdx file imports\",\n};\n// don't show the component in the docs created by mdx\nCSFStoriesWithArbitraryMDX.parameters = {\n  docs: {\n    page: mdx,\n  },\n};\n`}</code></pre>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport * as React from \\\\\\\"react\\\\\\\";\\\\n// @ts-ignore\\\\nimport mdx from \\\\\\\"./index.mdx\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} />;\\\\nCSFStoriesWithArbitraryMDX.args = {\\\\n  label: \\\\\\\"Documentation provided by arbitrary mdx file imports\\\\\\\",\\\\n};\\\\n// don't show the component in the docs created by mdx\\\\nCSFStoriesWithArbitraryMDX.parameters = {\\\\n  docs: {\\\\n    page: mdx,\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"CSFStoriesWithArbitraryMDX\\\":{\\\"startLoc\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endLoc\\\":{\\\"col\\\":25,\\\"line\\\":11},\\\"startBody\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endBody\\\":{\\\"col\\\":25,\\\"line\\\":11}}};\\n    \\nimport type { ComponentStory } from \\\"@storybook/react\\\";\\nimport * as React from \\\"react\\\";\\n// @ts-ignore\\nimport mdx from \\\"./index.mdx\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport * as React from \\\\\\\"react\\\\\\\";\\\\n// @ts-ignore\\\\nimport mdx from \\\\\\\"./index.mdx\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} />;\\\\nCSFStoriesWithArbitraryMDX.args = {\\\\n  label: \\\\\\\"Documentation provided by arbitrary mdx file imports\\\\\\\",\\\\n};\\\\n// don't show the component in the docs created by mdx\\\\nCSFStoriesWithArbitraryMDX.parameters = {\\\\n  docs: {\\\\n    page: mdx,\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"csf-stories-with-arbitrary-mdx\\\":{\\\"startLoc\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endLoc\\\":{\\\"col\\\":25,\\\"line\\\":11},\\\"startBody\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endBody\\\":{\\\"col\\\":25,\\\"line\\\":11}}}},}, component: Button };\\n\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\n  args\\n) => <Button {...args} />;\\nCSFStoriesWithArbitraryMDX.args = {\\n  label: \\\"Documentation provided by arbitrary mdx file imports\\\",\\n};\\n// don't show the component in the docs created by mdx\\nCSFStoriesWithArbitraryMDX.parameters = {\\n  docs: {\\n    page: mdx,\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"CSFStoriesWithArbitraryMDX\":{\"startLoc\":{\"col\":73,\"line\":17},\"endLoc\":{\"col\":25,\"line\":19},\"startBody\":{\"col\":73,\"line\":17},\"endBody\":{\"col\":25,\"line\":19}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import type { ComponentStory } from \\\"@storybook/react\\\";\\nimport * as React from \\\"react\\\";\\n// @ts-ignore\\nimport mdx from \\\"./index.mdx\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button };\\n\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\n  args\\n) => <Button {...args} />;\\nCSFStoriesWithArbitraryMDX.args = {\\n  label: \\\"Documentation provided by arbitrary mdx file imports\\\",\\n};\\n// don't show the component in the docs created by mdx\\nCSFStoriesWithArbitraryMDX.parameters = {\\n  docs: {\\n    page: mdx,\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"CSFStoriesWithArbitraryMDX\":{\"startLoc\":{\"col\":73,\"line\":9},\"endLoc\":{\"col\":25,\"line\":11},\"startBody\":{\"col\":73,\"line\":9},\"endBody\":{\"col\":25,\"line\":11}}};\n    \nimport type { ComponentStory } from \"@storybook/react\";\nimport * as React from \"react\";\n// @ts-ignore\nimport mdx from \"./index.mdx\";\nimport { Button } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport * as React from \\\\\\\"react\\\\\\\";\\\\n// @ts-ignore\\\\nimport mdx from \\\\\\\"./index.mdx\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} />;\\\\nCSFStoriesWithArbitraryMDX.args = {\\\\n  label: \\\\\\\"Documentation provided by arbitrary mdx file imports\\\\\\\",\\\\n};\\\\n// don't show the component in the docs created by mdx\\\\nCSFStoriesWithArbitraryMDX.parameters = {\\\\n  docs: {\\\\n    page: mdx,\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"CSFStoriesWithArbitraryMDX\\\":{\\\"startLoc\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endLoc\\\":{\\\"col\\\":25,\\\"line\\\":11},\\\"startBody\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endBody\\\":{\\\"col\\\":25,\\\"line\\\":11}}};\\n    \\nimport type { ComponentStory } from \\\"@storybook/react\\\";\\nimport * as React from \\\"react\\\";\\n// @ts-ignore\\nimport mdx from \\\"./index.mdx\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import type { ComponentStory } from \\\\\\\"@storybook/react\\\\\\\";\\\\nimport * as React from \\\\\\\"react\\\\\\\";\\\\n// @ts-ignore\\\\nimport mdx from \\\\\\\"./index.mdx\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\\\n  args\\\\n) => <Button {...args} />;\\\\nCSFStoriesWithArbitraryMDX.args = {\\\\n  label: \\\\\\\"Documentation provided by arbitrary mdx file imports\\\\\\\",\\\\n};\\\\n// don't show the component in the docs created by mdx\\\\nCSFStoriesWithArbitraryMDX.parameters = {\\\\n  docs: {\\\\n    page: mdx,\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"csf-stories-with-arbitrary-mdx\\\":{\\\"startLoc\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endLoc\\\":{\\\"col\\\":25,\\\"line\\\":11},\\\"startBody\\\":{\\\"col\\\":73,\\\"line\\\":9},\\\"endBody\\\":{\\\"col\\\":25,\\\"line\\\":11}}}},}, component: Button };\\n\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\n  args\\n) => <Button {...args} />;\\nCSFStoriesWithArbitraryMDX.args = {\\n  label: \\\"Documentation provided by arbitrary mdx file imports\\\",\\n};\\n// don't show the component in the docs created by mdx\\nCSFStoriesWithArbitraryMDX.parameters = {\\n  docs: {\\n    page: mdx,\\n  },\\n};\\n\",\"locationsMap\":{\"csf-stories-with-arbitrary-mdx\":{\"startLoc\":{\"col\":73,\"line\":17},\"endLoc\":{\"col\":25,\"line\":19},\"startBody\":{\"col\":73,\"line\":17},\"endBody\":{\"col\":25,\"line\":19}}}},\"storySource\":{\"source\":\"import type { ComponentStory } from \\\"@storybook/react\\\";\\nimport * as React from \\\"react\\\";\\n// @ts-ignore\\nimport mdx from \\\"./index.mdx\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button };\\n\\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\\n  args\\n) => <Button {...args} />;\\nCSFStoriesWithArbitraryMDX.args = {\\n  label: \\\"Documentation provided by arbitrary mdx file imports\\\",\\n};\\n// don't show the component in the docs created by mdx\\nCSFStoriesWithArbitraryMDX.parameters = {\\n  docs: {\\n    page: mdx,\\n  },\\n};\\n\",\"locationsMap\":{\"csf-stories-with-arbitrary-mdx\":{\"startLoc\":{\"col\":73,\"line\":9},\"endLoc\":{\"col\":25,\"line\":11},\"startBody\":{\"col\":73,\"line\":9},\"endBody\":{\"col\":25,\"line\":11}}}},}, component: Button };\n\nexport const CSFStoriesWithArbitraryMDX: ComponentStory<typeof Button> = (\n  args\n) => <Button {...args} />;\nCSFStoriesWithArbitraryMDX.args = {\n  label: \"Documentation provided by arbitrary mdx file imports\",\n};\n// don't show the component in the docs created by mdx\nCSFStoriesWithArbitraryMDX.parameters = {\n  docs: {\n    page: mdx,\n  },\n};\n","import type { ComponentStory } from \"@storybook/react\";\nimport * as React from \"react\";\nimport { Button } from \"stories\";\n\n// eslint-disable-next-line storybook/story-exports\nexport default {\n  component: Button,\n  // mdx generated docs\n  includeStories: [],\n  cyIncludeStories: true,\n};\n\nexport const DocsInMDX: ComponentStory<typeof Button> = (args) => (\n  <Button {...args} />\n);\nDocsInMDX.args = {\n  label: \"Documentation provided by mdx file while component is written in csf\",\n};\n// don't show the component in the docs created by mdx\nDocsInMDX.parameters = {\n  docs: { disable: true },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button, cyIncludeStories: [] };\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not Found!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: `External tests will need to manually call \\\\\\\\`cy.intercept\\\\\\\\` or\\\\n\\\\\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\\\\\``,\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"WillFetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":19}}};\\n    \\nimport * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button, cyIncludeStories: [] };\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not Found!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: `External tests will need to manually call \\\\\\\\`cy.intercept\\\\\\\\` or\\\\n\\\\\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\\\\\``,\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\",\\\"locationsMap\\\":{\\\"will-fetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":19}}}},}, component: Button, cyIncludeStories: [] };\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not Found!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: `External tests will need to manually call \\\\`cy.intercept\\\\` or\\n\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\``,\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"WillFetch\":{\"startLoc\":{\"col\":58,\"line\":15},\"endLoc\":{\"col\":1,\"line\":27},\"startBody\":{\"col\":58,\"line\":15},\"endBody\":{\"col\":1,\"line\":27}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button, cyIncludeStories: [] };\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not Found!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: `External tests will need to manually call \\\\`cy.intercept\\\\` or\\n\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\``,\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"WillFetch\":{\"startLoc\":{\"col\":58,\"line\":7},\"endLoc\":{\"col\":1,\"line\":19},\"startBody\":{\"col\":58,\"line\":7},\"endBody\":{\"col\":1,\"line\":19}}};\n    \nimport * as React from \"react\";\nimport type { ComponentStoryCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button, cyIncludeStories: [] };\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not Found!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: `External tests will need to manually call \\\\\\\\`cy.intercept\\\\\\\\` or\\\\n\\\\\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\\\\\``,\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"WillFetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":19}}};\\n    \\nimport * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button, cyIncludeStories: [] };\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not Found!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: `External tests will need to manually call \\\\\\\\`cy.intercept\\\\\\\\` or\\\\n\\\\\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\\\\\``,\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\",\\\"locationsMap\\\":{\\\"will-fetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":19}}}},}, component: Button, cyIncludeStories: [] };\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not Found!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: `External tests will need to manually call \\\\`cy.intercept\\\\` or\\n\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\``,\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\",\"locationsMap\":{\"will-fetch\":{\"startLoc\":{\"col\":58,\"line\":15},\"endLoc\":{\"col\":1,\"line\":27},\"startBody\":{\"col\":58,\"line\":15},\"endBody\":{\"col\":1,\"line\":27}}}},\"storySource\":{\"source\":\"import * as React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button, cyIncludeStories: [] };\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not Found!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: `External tests will need to manually call \\\\`cy.intercept\\\\` or\\n\\\\`mockToCyIntercept(Story.parameters.mockData)\\\\``,\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\",\"locationsMap\":{\"will-fetch\":{\"startLoc\":{\"col\":58,\"line\":7},\"endLoc\":{\"col\":1,\"line\":19},\"startBody\":{\"col\":58,\"line\":7},\"endBody\":{\"col\":1,\"line\":19}}}},}, component: Button, cyIncludeStories: [] };\n\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\n  const [label, setLabel] = React.useState(\"loading\");\n  React.useEffect(() => {\n    fetch(\"/api/label\")\n      .then((result) => {\n        if (result.ok) return result.json();\n        throw new Error(\"Not Found!\");\n      })\n      .then((result) => setLabel(result.data))\n      .catch((error) => setLabel(error.toString()));\n  }, []);\n  return <Button {...args} label={label} />;\n};\n\nWillFetch.parameters = {\n  mockData: [\n    {\n      url: \"/api/label\",\n      method: \"GET\",\n      status: 200,\n      response: { data: \"Loaded\" },\n    },\n  ],\n  // story-code @skip-start\n  docs: {\n    description: {\n      story: `External tests will need to manually call \\`cy.intercept\\` or\n\\`mockToCyIntercept(Story.parameters.mockData)\\``,\n    },\n  }, // story-code @skip-end\n};\n// story-code @end\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label?q=2\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not ok!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\\\n  // where a functional story must be present for code locations to exist\\\\n  render: WillFetch,\\\\n};\\\\n\\\\nWillFetch.cy = () => {\\\\n  cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n    expect(interception.request!.url).to.contain(\\\\\\\"q=2\\\\\\\");\\\\n    // maybe not worth testing in reality considering we know what we've mocked\\\\n    expect(interception.response!.statusCode).to.equal(200);\\\\n    expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n  });\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: \\\\\\\"Mock a simple API GET request via storybook-addon-mock\\\\\\\",\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const AliasedButWillFail = {\\\\n  ...WillFetch,\\\\n  parameters: {\\\\n    mockData: [\\\\n      {\\\\n        url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n        method: \\\\\\\"GET\\\\\\\",\\\\n        status: 500,\\\\n        response: { data: \\\\\\\"Failed\\\\\\\" },\\\\n        alias: \\\\\\\"label\\\\\\\",\\\\n      },\\\\n    ],\\\\n    // story-code @skip-start\\\\n    docs: {\\\\n      description: {\\\\n        story: `Will fail, but shows how to provide a specific label for a request.\\\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\\\non that tab. That's a known outcome of storybook-addon-mock.\\\\n`,\\\\n      },\\\\n    }, // story-code @skip-end\\\\n  },\\\\n  cy() {\\\\n    cy.wait(\\\\\\\"@label\\\\\\\").then((interception) => {\\\\n      expect(interception.response!.statusCode).to.equal(500);\\\\n      expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Failed\\\\\\\" });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\\\n  ...WillFetch,\\\\n  cyTest(Comp) {\\\\n    it(\\\\\\\"should require a manual call of `mockToCyIntercept`\\\\\\\", () => {\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n      });\\\\n    });\\\\n\\\\n    it(\\\\\\\"should allow manual intercept calls just fine\\\\\\\", () => {\\\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\\\n      cy.intercept(\\\\\\\"GET\\\\\\\", \\\\\\\"/api/label?q=2\\\\\\\", { body: { data: \\\\\\\"Manual\\\\\\\" } }).as(\\\\n        \\\\\\\"manual\\\\\\\"\\\\n      );\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@manual\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Manual\\\\\\\" });\\\\n      });\\\\n    });\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"WillFetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":17},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":17}}};\\n    \\nimport * as React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label?q=2\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not ok!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label?q=2\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not ok!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\\\n  // where a functional story must be present for code locations to exist\\\\n  render: WillFetch,\\\\n};\\\\n\\\\nWillFetch.cy = () => {\\\\n  cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n    expect(interception.request!.url).to.contain(\\\\\\\"q=2\\\\\\\");\\\\n    // maybe not worth testing in reality considering we know what we've mocked\\\\n    expect(interception.response!.statusCode).to.equal(200);\\\\n    expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n  });\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: \\\\\\\"Mock a simple API GET request via storybook-addon-mock\\\\\\\",\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const AliasedButWillFail = {\\\\n  ...WillFetch,\\\\n  parameters: {\\\\n    mockData: [\\\\n      {\\\\n        url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n        method: \\\\\\\"GET\\\\\\\",\\\\n        status: 500,\\\\n        response: { data: \\\\\\\"Failed\\\\\\\" },\\\\n        alias: \\\\\\\"label\\\\\\\",\\\\n      },\\\\n    ],\\\\n    // story-code @skip-start\\\\n    docs: {\\\\n      description: {\\\\n        story: `Will fail, but shows how to provide a specific label for a request.\\\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\\\non that tab. That's a known outcome of storybook-addon-mock.\\\\n`,\\\\n      },\\\\n    }, // story-code @skip-end\\\\n  },\\\\n  cy() {\\\\n    cy.wait(\\\\\\\"@label\\\\\\\").then((interception) => {\\\\n      expect(interception.response!.statusCode).to.equal(500);\\\\n      expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Failed\\\\\\\" });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\\\n  ...WillFetch,\\\\n  cyTest(Comp) {\\\\n    it(\\\\\\\"should require a manual call of `mockToCyIntercept`\\\\\\\", () => {\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n      });\\\\n    });\\\\n\\\\n    it(\\\\\\\"should allow manual intercept calls just fine\\\\\\\", () => {\\\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\\\n      cy.intercept(\\\\\\\"GET\\\\\\\", \\\\\\\"/api/label?q=2\\\\\\\", { body: { data: \\\\\\\"Manual\\\\\\\" } }).as(\\\\n        \\\\\\\"manual\\\\\\\"\\\\n      );\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@manual\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Manual\\\\\\\" });\\\\n      });\\\\n    });\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"will-fetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":17},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":17}}}},},\\n  component: Button,\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\n  // where a functional story must be present for code locations to exist\\n  render: WillFetch,\\n};\\n\\nWillFetch.cy = () => {\\n  cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n    expect(interception.request!.url).to.contain(\\\"q=2\\\");\\n    // maybe not worth testing in reality considering we know what we've mocked\\n    expect(interception.response!.statusCode).to.equal(200);\\n    expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n  });\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label?q=2\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: \\\"Mock a simple API GET request via storybook-addon-mock\\\",\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\\nexport const AliasedButWillFail = {\\n  ...WillFetch,\\n  parameters: {\\n    mockData: [\\n      {\\n        url: \\\"/api/label?q=2\\\",\\n        method: \\\"GET\\\",\\n        status: 500,\\n        response: { data: \\\"Failed\\\" },\\n        alias: \\\"label\\\",\\n      },\\n    ],\\n    // story-code @skip-start\\n    docs: {\\n      description: {\\n        story: `Will fail, but shows how to provide a specific label for a request.\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\non that tab. That's a known outcome of storybook-addon-mock.\\n`,\\n      },\\n    }, // story-code @skip-end\\n  },\\n  cy() {\\n    cy.wait(\\\"@label\\\").then((interception) => {\\n      expect(interception.response!.statusCode).to.equal(500);\\n      expect(interception.response!.body).to.deep.equal({ data: \\\"Failed\\\" });\\n    });\\n  },\\n};\\n\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\n  ...WillFetch,\\n  cyTest(Comp) {\\n    it(\\\"should require a manual call of `mockToCyIntercept`\\\", () => {\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n      });\\n    });\\n\\n    it(\\\"should allow manual intercept calls just fine\\\", () => {\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\n      cy.intercept(\\\"GET\\\", \\\"/api/label?q=2\\\", { body: { data: \\\"Manual\\\" } }).as(\\n        \\\"manual\\\"\\n      );\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@manual\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Manual\\\" });\\n      });\\n    });\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"WillFetch\":{\"startLoc\":{\"col\":58,\"line\":13},\"endLoc\":{\"col\":1,\"line\":25},\"startBody\":{\"col\":58,\"line\":13},\"endBody\":{\"col\":1,\"line\":25}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label?q=2\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not ok!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nexport default {\\n  component: Button,\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\n  // where a functional story must be present for code locations to exist\\n  render: WillFetch,\\n};\\n\\nWillFetch.cy = () => {\\n  cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n    expect(interception.request!.url).to.contain(\\\"q=2\\\");\\n    // maybe not worth testing in reality considering we know what we've mocked\\n    expect(interception.response!.statusCode).to.equal(200);\\n    expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n  });\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label?q=2\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: \\\"Mock a simple API GET request via storybook-addon-mock\\\",\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\\nexport const AliasedButWillFail = {\\n  ...WillFetch,\\n  parameters: {\\n    mockData: [\\n      {\\n        url: \\\"/api/label?q=2\\\",\\n        method: \\\"GET\\\",\\n        status: 500,\\n        response: { data: \\\"Failed\\\" },\\n        alias: \\\"label\\\",\\n      },\\n    ],\\n    // story-code @skip-start\\n    docs: {\\n      description: {\\n        story: `Will fail, but shows how to provide a specific label for a request.\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\non that tab. That's a known outcome of storybook-addon-mock.\\n`,\\n      },\\n    }, // story-code @skip-end\\n  },\\n  cy() {\\n    cy.wait(\\\"@label\\\").then((interception) => {\\n      expect(interception.response!.statusCode).to.equal(500);\\n      expect(interception.response!.body).to.deep.equal({ data: \\\"Failed\\\" });\\n    });\\n  },\\n};\\n\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\n  ...WillFetch,\\n  cyTest(Comp) {\\n    it(\\\"should require a manual call of `mockToCyIntercept`\\\", () => {\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n      });\\n    });\\n\\n    it(\\\"should allow manual intercept calls just fine\\\", () => {\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\n      cy.intercept(\\\"GET\\\", \\\"/api/label?q=2\\\", { body: { data: \\\"Manual\\\" } }).as(\\n        \\\"manual\\\"\\n      );\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@manual\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Manual\\\" });\\n      });\\n    });\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"WillFetch\":{\"startLoc\":{\"col\":58,\"line\":5},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":58,\"line\":5},\"endBody\":{\"col\":1,\"line\":17}}};\n    \nimport * as React from \"react\";\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\n\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\n  const [label, setLabel] = React.useState(\"loading\");\n  React.useEffect(() => {\n    fetch(\"/api/label?q=2\")\n      .then((result) => {\n        if (result.ok) return result.json();\n        throw new Error(\"Not ok!\");\n      })\n      .then((result) => setLabel(result.data))\n      .catch((error) => setLabel(error.toString()));\n  }, []);\n  return <Button {...args} label={label} />;\n};\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label?q=2\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not ok!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\\\n  // where a functional story must be present for code locations to exist\\\\n  render: WillFetch,\\\\n};\\\\n\\\\nWillFetch.cy = () => {\\\\n  cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n    expect(interception.request!.url).to.contain(\\\\\\\"q=2\\\\\\\");\\\\n    // maybe not worth testing in reality considering we know what we've mocked\\\\n    expect(interception.response!.statusCode).to.equal(200);\\\\n    expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n  });\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: \\\\\\\"Mock a simple API GET request via storybook-addon-mock\\\\\\\",\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const AliasedButWillFail = {\\\\n  ...WillFetch,\\\\n  parameters: {\\\\n    mockData: [\\\\n      {\\\\n        url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n        method: \\\\\\\"GET\\\\\\\",\\\\n        status: 500,\\\\n        response: { data: \\\\\\\"Failed\\\\\\\" },\\\\n        alias: \\\\\\\"label\\\\\\\",\\\\n      },\\\\n    ],\\\\n    // story-code @skip-start\\\\n    docs: {\\\\n      description: {\\\\n        story: `Will fail, but shows how to provide a specific label for a request.\\\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\\\non that tab. That's a known outcome of storybook-addon-mock.\\\\n`,\\\\n      },\\\\n    }, // story-code @skip-end\\\\n  },\\\\n  cy() {\\\\n    cy.wait(\\\\\\\"@label\\\\\\\").then((interception) => {\\\\n      expect(interception.response!.statusCode).to.equal(500);\\\\n      expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Failed\\\\\\\" });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\\\n  ...WillFetch,\\\\n  cyTest(Comp) {\\\\n    it(\\\\\\\"should require a manual call of `mockToCyIntercept`\\\\\\\", () => {\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n      });\\\\n    });\\\\n\\\\n    it(\\\\\\\"should allow manual intercept calls just fine\\\\\\\", () => {\\\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\\\n      cy.intercept(\\\\\\\"GET\\\\\\\", \\\\\\\"/api/label?q=2\\\\\\\", { body: { data: \\\\\\\"Manual\\\\\\\" } }).as(\\\\n        \\\\\\\"manual\\\\\\\"\\\\n      );\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@manual\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Manual\\\\\\\" });\\\\n      });\\\\n    });\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"WillFetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":17},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":17}}};\\n    \\nimport * as React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label?q=2\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not ok!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import * as React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\\\n  const [label, setLabel] = React.useState(\\\\\\\"loading\\\\\\\");\\\\n  React.useEffect(() => {\\\\n    fetch(\\\\\\\"/api/label?q=2\\\\\\\")\\\\n      .then((result) => {\\\\n        if (result.ok) return result.json();\\\\n        throw new Error(\\\\\\\"Not ok!\\\\\\\");\\\\n      })\\\\n      .then((result) => setLabel(result.data))\\\\n      .catch((error) => setLabel(error.toString()));\\\\n  }, []);\\\\n  return <Button {...args} label={label} />;\\\\n};\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\\\n  // where a functional story must be present for code locations to exist\\\\n  render: WillFetch,\\\\n};\\\\n\\\\nWillFetch.cy = () => {\\\\n  cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n    expect(interception.request!.url).to.contain(\\\\\\\"q=2\\\\\\\");\\\\n    // maybe not worth testing in reality considering we know what we've mocked\\\\n    expect(interception.response!.statusCode).to.equal(200);\\\\n    expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n  });\\\\n};\\\\n\\\\nWillFetch.parameters = {\\\\n  mockData: [\\\\n    {\\\\n      url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n      method: \\\\\\\"GET\\\\\\\",\\\\n      status: 200,\\\\n      response: { data: \\\\\\\"Loaded\\\\\\\" },\\\\n    },\\\\n  ],\\\\n  // story-code @skip-start\\\\n  docs: {\\\\n    description: {\\\\n      story: \\\\\\\"Mock a simple API GET request via storybook-addon-mock\\\\\\\",\\\\n    },\\\\n  }, // story-code @skip-end\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const AliasedButWillFail = {\\\\n  ...WillFetch,\\\\n  parameters: {\\\\n    mockData: [\\\\n      {\\\\n        url: \\\\\\\"/api/label?q=2\\\\\\\",\\\\n        method: \\\\\\\"GET\\\\\\\",\\\\n        status: 500,\\\\n        response: { data: \\\\\\\"Failed\\\\\\\" },\\\\n        alias: \\\\\\\"label\\\\\\\",\\\\n      },\\\\n    ],\\\\n    // story-code @skip-start\\\\n    docs: {\\\\n      description: {\\\\n        story: `Will fail, but shows how to provide a specific label for a request.\\\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\\\non that tab. That's a known outcome of storybook-addon-mock.\\\\n`,\\\\n      },\\\\n    }, // story-code @skip-end\\\\n  },\\\\n  cy() {\\\\n    cy.wait(\\\\\\\"@label\\\\\\\").then((interception) => {\\\\n      expect(interception.response!.statusCode).to.equal(500);\\\\n      expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Failed\\\\\\\" });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\\\n  ...WillFetch,\\\\n  cyTest(Comp) {\\\\n    it(\\\\\\\"should require a manual call of `mockToCyIntercept`\\\\\\\", () => {\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@/api/label?q=2\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Loaded\\\\\\\" });\\\\n      });\\\\n    });\\\\n\\\\n    it(\\\\\\\"should allow manual intercept calls just fine\\\\\\\", () => {\\\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\\\n      cy.intercept(\\\\\\\"GET\\\\\\\", \\\\\\\"/api/label?q=2\\\\\\\", { body: { data: \\\\\\\"Manual\\\\\\\" } }).as(\\\\n        \\\\\\\"manual\\\\\\\"\\\\n      );\\\\n      cy.mount(<Comp />);\\\\n      cy.wait(\\\\\\\"@manual\\\\\\\").then((interception) => {\\\\n        expect(interception.response!.body).to.deep.equal({ data: \\\\\\\"Manual\\\\\\\" });\\\\n      });\\\\n    });\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"will-fetch\\\":{\\\"startLoc\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":17},\\\"startBody\\\":{\\\"col\\\":58,\\\"line\\\":5},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":17}}}},},\\n  component: Button,\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\n  // where a functional story must be present for code locations to exist\\n  render: WillFetch,\\n};\\n\\nWillFetch.cy = () => {\\n  cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n    expect(interception.request!.url).to.contain(\\\"q=2\\\");\\n    // maybe not worth testing in reality considering we know what we've mocked\\n    expect(interception.response!.statusCode).to.equal(200);\\n    expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n  });\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label?q=2\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: \\\"Mock a simple API GET request via storybook-addon-mock\\\",\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\\nexport const AliasedButWillFail = {\\n  ...WillFetch,\\n  parameters: {\\n    mockData: [\\n      {\\n        url: \\\"/api/label?q=2\\\",\\n        method: \\\"GET\\\",\\n        status: 500,\\n        response: { data: \\\"Failed\\\" },\\n        alias: \\\"label\\\",\\n      },\\n    ],\\n    // story-code @skip-start\\n    docs: {\\n      description: {\\n        story: `Will fail, but shows how to provide a specific label for a request.\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\non that tab. That's a known outcome of storybook-addon-mock.\\n`,\\n      },\\n    }, // story-code @skip-end\\n  },\\n  cy() {\\n    cy.wait(\\\"@label\\\").then((interception) => {\\n      expect(interception.response!.statusCode).to.equal(500);\\n      expect(interception.response!.body).to.deep.equal({ data: \\\"Failed\\\" });\\n    });\\n  },\\n};\\n\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\n  ...WillFetch,\\n  cyTest(Comp) {\\n    it(\\\"should require a manual call of `mockToCyIntercept`\\\", () => {\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n      });\\n    });\\n\\n    it(\\\"should allow manual intercept calls just fine\\\", () => {\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\n      cy.intercept(\\\"GET\\\", \\\"/api/label?q=2\\\", { body: { data: \\\"Manual\\\" } }).as(\\n        \\\"manual\\\"\\n      );\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@manual\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Manual\\\" });\\n      });\\n    });\\n  },\\n};\\n\",\"locationsMap\":{\"will-fetch\":{\"startLoc\":{\"col\":58,\"line\":13},\"endLoc\":{\"col\":1,\"line\":25},\"startBody\":{\"col\":58,\"line\":13},\"endBody\":{\"col\":1,\"line\":25}}}},\"storySource\":{\"source\":\"import * as React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport const WillFetch: ComponentStoryCy<typeof Button> = (args) => {\\n  const [label, setLabel] = React.useState(\\\"loading\\\");\\n  React.useEffect(() => {\\n    fetch(\\\"/api/label?q=2\\\")\\n      .then((result) => {\\n        if (result.ok) return result.json();\\n        throw new Error(\\\"Not ok!\\\");\\n      })\\n      .then((result) => setLabel(result.data))\\n      .catch((error) => setLabel(error.toString()));\\n  }, []);\\n  return <Button {...args} label={label} />;\\n};\\n\\nexport default {\\n  component: Button,\\n  // bit of a weird pattern here to allow spread and work around storysource bug\\n  // where a functional story must be present for code locations to exist\\n  render: WillFetch,\\n};\\n\\nWillFetch.cy = () => {\\n  cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n    expect(interception.request!.url).to.contain(\\\"q=2\\\");\\n    // maybe not worth testing in reality considering we know what we've mocked\\n    expect(interception.response!.statusCode).to.equal(200);\\n    expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n  });\\n};\\n\\nWillFetch.parameters = {\\n  mockData: [\\n    {\\n      url: \\\"/api/label?q=2\\\",\\n      method: \\\"GET\\\",\\n      status: 200,\\n      response: { data: \\\"Loaded\\\" },\\n    },\\n  ],\\n  // story-code @skip-start\\n  docs: {\\n    description: {\\n      story: \\\"Mock a simple API GET request via storybook-addon-mock\\\",\\n    },\\n  }, // story-code @skip-end\\n};\\n// story-code @end\\n\\nexport const AliasedButWillFail = {\\n  ...WillFetch,\\n  parameters: {\\n    mockData: [\\n      {\\n        url: \\\"/api/label?q=2\\\",\\n        method: \\\"GET\\\",\\n        status: 500,\\n        response: { data: \\\"Failed\\\" },\\n        alias: \\\"label\\\",\\n      },\\n    ],\\n    // story-code @skip-start\\n    docs: {\\n      description: {\\n        story: `Will fail, but shows how to provide a specific label for a request.\\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\\non that tab. That's a known outcome of storybook-addon-mock.\\n`,\\n      },\\n    }, // story-code @skip-end\\n  },\\n  cy() {\\n    cy.wait(\\\"@label\\\").then((interception) => {\\n      expect(interception.response!.statusCode).to.equal(500);\\n      expect(interception.response!.body).to.deep.equal({ data: \\\"Failed\\\" });\\n    });\\n  },\\n};\\n\\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\\n  ...WillFetch,\\n  cyTest(Comp) {\\n    it(\\\"should require a manual call of `mockToCyIntercept`\\\", () => {\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@/api/label?q=2\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Loaded\\\" });\\n      });\\n    });\\n\\n    it(\\\"should allow manual intercept calls just fine\\\", () => {\\n      // you could do this instead, here or in a beforeEach or in default `cy` param\\n      cy.intercept(\\\"GET\\\", \\\"/api/label?q=2\\\", { body: { data: \\\"Manual\\\" } }).as(\\n        \\\"manual\\\"\\n      );\\n      cy.mount(<Comp />);\\n      cy.wait(\\\"@manual\\\").then((interception) => {\\n        expect(interception.response!.body).to.deep.equal({ data: \\\"Manual\\\" });\\n      });\\n    });\\n  },\\n};\\n\",\"locationsMap\":{\"will-fetch\":{\"startLoc\":{\"col\":58,\"line\":5},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":58,\"line\":5},\"endBody\":{\"col\":1,\"line\":17}}}},},\n  component: Button,\n  // bit of a weird pattern here to allow spread and work around storysource bug\n  // where a functional story must be present for code locations to exist\n  render: WillFetch,\n};\n\nWillFetch.cy = () => {\n  cy.wait(\"@/api/label?q=2\").then((interception) => {\n    expect(interception.request!.url).to.contain(\"q=2\");\n    // maybe not worth testing in reality considering we know what we've mocked\n    expect(interception.response!.statusCode).to.equal(200);\n    expect(interception.response!.body).to.deep.equal({ data: \"Loaded\" });\n  });\n};\n\nWillFetch.parameters = {\n  mockData: [\n    {\n      url: \"/api/label?q=2\",\n      method: \"GET\",\n      status: 200,\n      response: { data: \"Loaded\" },\n    },\n  ],\n  // story-code @skip-start\n  docs: {\n    description: {\n      story: \"Mock a simple API GET request via storybook-addon-mock\",\n    },\n  }, // story-code @skip-end\n};\n// story-code @end\n\nexport const AliasedButWillFail = {\n  ...WillFetch,\n  parameters: {\n    mockData: [\n      {\n        url: \"/api/label?q=2\",\n        method: \"GET\",\n        status: 500,\n        response: { data: \"Failed\" },\n        alias: \"label\",\n      },\n    ],\n    // story-code @skip-start\n    docs: {\n      description: {\n        story: `Will fail, but shows how to provide a specific label for a request.\nNOTE: storybook docs only has the single request so you'll only see the one 'Loaded' label\non that tab. That's a known outcome of storybook-addon-mock.\n`,\n      },\n    }, // story-code @skip-end\n  },\n  cy() {\n    cy.wait(\"@label\").then((interception) => {\n      expect(interception.response!.statusCode).to.equal(500);\n      expect(interception.response!.body).to.deep.equal({ data: \"Failed\" });\n    });\n  },\n};\n\nexport const CyTestFormatAlsoAutoMocks: ComponentStoryObjCy<typeof Button> = {\n  ...WillFetch,\n  cyTest(Comp) {\n    it(\"should require a manual call of `mockToCyIntercept`\", () => {\n      cy.mount(<Comp />);\n      cy.wait(\"@/api/label?q=2\").then((interception) => {\n        expect(interception.response!.body).to.deep.equal({ data: \"Loaded\" });\n      });\n    });\n\n    it(\"should allow manual intercept calls just fine\", () => {\n      // you could do this instead, here or in a beforeEach or in default `cy` param\n      cy.intercept(\"GET\", \"/api/label?q=2\", { body: { data: \"Manual\" } }).as(\n        \"manual\"\n      );\n      cy.mount(<Comp />);\n      cy.wait(\"@manual\").then((interception) => {\n        expect(interception.response!.body).to.deep.equal({ data: \"Manual\" });\n      });\n    });\n  },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cySkip: true,\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      page: mdxObj[\\\\\\\"fully-skipped\\\\\\\"],\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkipped.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end @include-default\\\\n\\\\nexport const Another = {\\\\n  ...Skipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"Skipped\\\":{\\\"startLoc\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":22},\\\"startBody\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":22}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\n\\nexport default {\\n  component: Button,\\n  cySkip: true,\\n  // story-code @skip-start\\n  parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cySkip: true,\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      page: mdxObj[\\\\\\\"fully-skipped\\\\\\\"],\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkipped.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end @include-default\\\\n\\\\nexport const Another = {\\\\n  ...Skipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"skipped\\\":{\\\"startLoc\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":22},\\\"startBody\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":22}}}},\\n    docs: {\\n      page: mdxObj[\\\"fully-skipped\\\"],\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkipped.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end @include-default\\n\\nexport const Another = {\\n  ...Skipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Skipped\":{\"startLoc\":{\"col\":56,\"line\":28},\"endLoc\":{\"col\":1,\"line\":30},\"startBody\":{\"col\":56,\"line\":28},\"endBody\":{\"col\":1,\"line\":30}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\n\\nexport default {\\n  component: Button,\\n  cySkip: true,\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      page: mdxObj[\\\"fully-skipped\\\"],\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkipped.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end @include-default\\n\\nexport const Another = {\\n  ...Skipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Skipped\":{\"startLoc\":{\"col\":56,\"line\":20},\"endLoc\":{\"col\":1,\"line\":22},\"startBody\":{\"col\":56,\"line\":20},\"endBody\":{\"col\":1,\"line\":22}}};\n    \nimport React from \"react\";\nimport type { ComponentStoryCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\nimport mdxObj from \"./mdx\";\n\n// eslint-disable-next-line storybook/story-exports\nexport default {\n  component: Button,\n  cySkip: true,\n  // story-code @skip-start\n  parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cySkip: true,\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      page: mdxObj[\\\\\\\"fully-skipped\\\\\\\"],\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkipped.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end @include-default\\\\n\\\\nexport const Another = {\\\\n  ...Skipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"Skipped\\\":{\\\"startLoc\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":22},\\\"startBody\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":22}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\n\\nexport default {\\n  component: Button,\\n  cySkip: true,\\n  // story-code @skip-start\\n  parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cySkip: true,\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      page: mdxObj[\\\\\\\"fully-skipped\\\\\\\"],\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkipped.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end @include-default\\\\n\\\\nexport const Another = {\\\\n  ...Skipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"skipped\\\":{\\\"startLoc\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":22},\\\"startBody\\\":{\\\"col\\\":56,\\\"line\\\":20},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":22}}}},\\n    docs: {\\n      page: mdxObj[\\\"fully-skipped\\\"],\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkipped.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end @include-default\\n\\nexport const Another = {\\n  ...Skipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\",\"locationsMap\":{\"skipped\":{\"startLoc\":{\"col\":56,\"line\":28},\"endLoc\":{\"col\":1,\"line\":30},\"startBody\":{\"col\":56,\"line\":28},\"endBody\":{\"col\":1,\"line\":30}}}},\"storySource\":{\"source\":\"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\n\\nexport default {\\n  component: Button,\\n  cySkip: true,\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      page: mdxObj[\\\"fully-skipped\\\"],\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkipped.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end @include-default\\n\\nexport const Another = {\\n  ...Skipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\",\"locationsMap\":{\"skipped\":{\"startLoc\":{\"col\":56,\"line\":20},\"endLoc\":{\"col\":1,\"line\":22},\"startBody\":{\"col\":56,\"line\":20},\"endBody\":{\"col\":1,\"line\":22}}}},\n    docs: {\n      page: mdxObj[\"fully-skipped\"],\n    },\n  },\n  // story-code @skip-end\n};\n\n/* istanbul ignore next */ // story-code @skip\nexport const Skipped: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);\n\n/* istanbul ignore next */ // story-code @skip\nSkipped.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\");\n// story-code @end @include-default\n\nexport const Another = {\n  ...Skipped,\n  args: { label: \"Another\" },\n  cy:\n    /* istanbul ignore next */ // story-code @skip\n    () => cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\"),\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cyIncludeStories: [\\\\\\\"NotSkippedFunction\\\\\\\", \\\\\\\"NotSkippedObject\\\\\\\"],\\\\n  id: \\\\\\\"ignoring-via-cyincludestories\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkippedFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      /* istanbul ignore else */ // story-code @skip\\\\n      story: mdxObj[\\\\\\\"ignoring-via-cyincludestories\\\\\\\"]?.md,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end\\\\n\\\\nexport const NotSkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Another\\\\\\\"),\\\\n};\\\\n\\\\nexport const SkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"NotSkippedFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":14},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":14}},\\\"SkippedFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":31},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":31}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cyIncludeStories: [\\\\\\\"NotSkippedFunction\\\\\\\", \\\\\\\"NotSkippedObject\\\\\\\"],\\\\n  id: \\\\\\\"ignoring-via-cyincludestories\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkippedFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      /* istanbul ignore else */ // story-code @skip\\\\n      story: mdxObj[\\\\\\\"ignoring-via-cyincludestories\\\\\\\"]?.md,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end\\\\n\\\\nexport const NotSkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Another\\\\\\\"),\\\\n};\\\\n\\\\nexport const SkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"not-skipped-function\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":14},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":14}},\\\"skipped-function\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":31},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":31}}}},},\\n  component: Button,\\n  cyIncludeStories: [\\\"NotSkippedFunction\\\", \\\"NotSkippedObject\\\"],\\n  id: \\\"ignoring-via-cyincludestories\\\", // story-code @skip\\n};\\n\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);;\\n\\nNotSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkippedFunction.parameters = {\\n  docs: {\\n    description: {\\n      /* istanbul ignore else */ // story-code @skip\\n      story: mdxObj[\\\"ignoring-via-cyincludestories\\\"]?.md,\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end\\n\\nexport const NotSkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Another\\\"),\\n};\\n\\nexport const SkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"NotSkippedFunction\":{\"startLoc\":{\"col\":67,\"line\":20},\"endLoc\":{\"col\":1,\"line\":22},\"startBody\":{\"col\":67,\"line\":20},\"endBody\":{\"col\":1,\"line\":22}},\"SkippedFunction\":{\"startLoc\":{\"col\":64,\"line\":37},\"endLoc\":{\"col\":1,\"line\":39},\"startBody\":{\"col\":64,\"line\":37},\"endBody\":{\"col\":1,\"line\":39}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\nexport default {\\n  component: Button,\\n  cyIncludeStories: [\\\"NotSkippedFunction\\\", \\\"NotSkippedObject\\\"],\\n  id: \\\"ignoring-via-cyincludestories\\\", // story-code @skip\\n};\\n\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\nNotSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkippedFunction.parameters = {\\n  docs: {\\n    description: {\\n      /* istanbul ignore else */ // story-code @skip\\n      story: mdxObj[\\\"ignoring-via-cyincludestories\\\"]?.md,\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end\\n\\nexport const NotSkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Another\\\"),\\n};\\n\\nexport const SkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"NotSkippedFunction\":{\"startLoc\":{\"col\":67,\"line\":12},\"endLoc\":{\"col\":1,\"line\":14},\"startBody\":{\"col\":67,\"line\":12},\"endBody\":{\"col\":1,\"line\":14}},\"SkippedFunction\":{\"startLoc\":{\"col\":64,\"line\":29},\"endLoc\":{\"col\":1,\"line\":31},\"startBody\":{\"col\":64,\"line\":29},\"endBody\":{\"col\":1,\"line\":31}}};\n    \nimport React from \"react\";\nimport type { ComponentStoryCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\nimport mdxObj from \"./mdx\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cyIncludeStories: [\\\\\\\"NotSkippedFunction\\\\\\\", \\\\\\\"NotSkippedObject\\\\\\\"],\\\\n  id: \\\\\\\"ignoring-via-cyincludestories\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkippedFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      /* istanbul ignore else */ // story-code @skip\\\\n      story: mdxObj[\\\\\\\"ignoring-via-cyincludestories\\\\\\\"]?.md,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end\\\\n\\\\nexport const NotSkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Another\\\\\\\"),\\\\n};\\\\n\\\\nexport const SkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"NotSkippedFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":14},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":14}},\\\"SkippedFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":31},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":31}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\nimport mdxObj from \\\\\\\"./mdx\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: Button,\\\\n  cyIncludeStories: [\\\\\\\"NotSkippedFunction\\\\\\\", \\\\\\\"NotSkippedObject\\\\\\\"],\\\\n  id: \\\\\\\"ignoring-via-cyincludestories\\\\\\\", // story-code @skip\\\\n};\\\\n\\\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkippedFunction.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      /* istanbul ignore else */ // story-code @skip\\\\n      story: mdxObj[\\\\\\\"ignoring-via-cyincludestories\\\\\\\"]?.md,\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\n// story-code @end\\\\n\\\\nexport const NotSkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy: () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Another\\\\\\\"),\\\\n};\\\\n\\\\nexport const SkippedObject = {\\\\n  ...SkippedFunction,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"not-skipped-function\\\":{\\\"startLoc\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":14},\\\"startBody\\\":{\\\"col\\\":67,\\\"line\\\":12},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":14}},\\\"skipped-function\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":31},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":29},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":31}}}},},\\n  component: Button,\\n  cyIncludeStories: [\\\"NotSkippedFunction\\\", \\\"NotSkippedObject\\\"],\\n  id: \\\"ignoring-via-cyincludestories\\\", // story-code @skip\\n};\\n\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);;\\n\\nNotSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkippedFunction.parameters = {\\n  docs: {\\n    description: {\\n      /* istanbul ignore else */ // story-code @skip\\n      story: mdxObj[\\\"ignoring-via-cyincludestories\\\"]?.md,\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end\\n\\nexport const NotSkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Another\\\"),\\n};\\n\\nexport const SkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\",\"locationsMap\":{\"not-skipped-function\":{\"startLoc\":{\"col\":67,\"line\":20},\"endLoc\":{\"col\":1,\"line\":22},\"startBody\":{\"col\":67,\"line\":20},\"endBody\":{\"col\":1,\"line\":22}},\"skipped-function\":{\"startLoc\":{\"col\":64,\"line\":37},\"endLoc\":{\"col\":1,\"line\":39},\"startBody\":{\"col\":64,\"line\":37},\"endBody\":{\"col\":1,\"line\":39}}}},\"storySource\":{\"source\":\"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\nimport mdxObj from \\\"./mdx\\\";\\n\\nexport default {\\n  component: Button,\\n  cyIncludeStories: [\\\"NotSkippedFunction\\\", \\\"NotSkippedObject\\\"],\\n  id: \\\"ignoring-via-cyincludestories\\\", // story-code @skip\\n};\\n\\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\nNotSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkippedFunction.parameters = {\\n  docs: {\\n    description: {\\n      /* istanbul ignore else */ // story-code @skip\\n      story: mdxObj[\\\"ignoring-via-cyincludestories\\\"]?.md,\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\n// story-code @end\\n\\nexport const NotSkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy: () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Another\\\"),\\n};\\n\\nexport const SkippedObject = {\\n  ...SkippedFunction,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n};\\n\",\"locationsMap\":{\"not-skipped-function\":{\"startLoc\":{\"col\":67,\"line\":12},\"endLoc\":{\"col\":1,\"line\":14},\"startBody\":{\"col\":67,\"line\":12},\"endBody\":{\"col\":1,\"line\":14}},\"skipped-function\":{\"startLoc\":{\"col\":64,\"line\":29},\"endLoc\":{\"col\":1,\"line\":31},\"startBody\":{\"col\":64,\"line\":29},\"endBody\":{\"col\":1,\"line\":31}}}},},\n  component: Button,\n  cyIncludeStories: [\"NotSkippedFunction\", \"NotSkippedObject\"],\n  id: \"ignoring-via-cyincludestories\", // story-code @skip\n};\n\nexport const NotSkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);;;\n\nNotSkippedFunction.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Story function\");\n// story-code @end @include-default\nNotSkippedFunction.parameters = {\n  docs: {\n    description: {\n      /* istanbul ignore else */ // story-code @skip\n      story: mdxObj[\"ignoring-via-cyincludestories\"]?.md,\n    },\n  },\n};\n\n/* istanbul ignore next */ // story-code @skip\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);\n/* istanbul ignore next */ // story-code @skip\nSkippedFunction.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\");\n// story-code @end\n\nexport const NotSkippedObject = {\n  ...SkippedFunction,\n  args: { label: \"Another\" },\n  cy: () => cy.dataCy(\"button\").should(\"contain\", \"Another\"),\n};\n\nexport const SkippedObject = {\n  ...SkippedFunction,\n  args: { label: \"Another\" },\n  cy:\n    /* istanbul ignore next */ // story-code @skip\n    () => cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\"),\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkipped.cy = () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkipped.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"You can skip individual stories via `.cySkip` property on the story itself.\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\nSkippedFunction.cySkip = true;\\\\n// story-code @end\\\\n\\\\nexport const Skipped = {\\\\n  ...NotSkipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n  cySkip: true,\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"NotSkipped\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"SkippedFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":25},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":25}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkipped.cy = () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkipped.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"You can skip individual stories via `.cySkip` property on the story itself.\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\nSkippedFunction.cySkip = true;\\\\n// story-code @end\\\\n\\\\nexport const Skipped = {\\\\n  ...NotSkipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n  cySkip: true,\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"not-skipped\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"skipped-function\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":25},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":25}}}},}, component: Button };\\n\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);;\\n\\nNotSkipped.cy = () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkipped.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"You can skip individual stories via `.cySkip` property on the story itself.\\\",\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\nSkippedFunction.cySkip = true;\\n// story-code @end\\n\\nexport const Skipped = {\\n  ...NotSkipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n  cySkip: true,\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"NotSkipped\":{\"startLoc\":{\"col\":59,\"line\":15},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":59,\"line\":15},\"endBody\":{\"col\":1,\"line\":17}},\"SkippedFunction\":{\"startLoc\":{\"col\":64,\"line\":31},\"endLoc\":{\"col\":1,\"line\":33},\"startBody\":{\"col\":64,\"line\":31},\"endBody\":{\"col\":1,\"line\":33}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button };\\n\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\nNotSkipped.cy = () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkipped.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"You can skip individual stories via `.cySkip` property on the story itself.\\\",\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\nSkippedFunction.cySkip = true;\\n// story-code @end\\n\\nexport const Skipped = {\\n  ...NotSkipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n  cySkip: true,\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"NotSkipped\":{\"startLoc\":{\"col\":59,\"line\":7},\"endLoc\":{\"col\":1,\"line\":9},\"startBody\":{\"col\":59,\"line\":7},\"endBody\":{\"col\":1,\"line\":9}},\"SkippedFunction\":{\"startLoc\":{\"col\":64,\"line\":23},\"endLoc\":{\"col\":1,\"line\":25},\"startBody\":{\"col\":64,\"line\":23},\"endBody\":{\"col\":1,\"line\":25}}};\n    \nimport React from \"react\";\nimport type { ComponentStoryCy } from \"orphic-cypress\";\nimport { Button } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkipped.cy = () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkipped.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"You can skip individual stories via `.cySkip` property on the story itself.\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\nSkippedFunction.cySkip = true;\\\\n// story-code @end\\\\n\\\\nexport const Skipped = {\\\\n  ...NotSkipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n  cySkip: true,\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"NotSkipped\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"SkippedFunction\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":25},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":25}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { Button } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: Button };\\\\n\\\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\nNotSkipped.cy = () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Story function\\\\\\\");\\\\n// story-code @end @include-default\\\\nNotSkipped.parameters = {\\\\n  docs: {\\\\n    description: {\\\\n      story:\\\\n        \\\\\\\"You can skip individual stories via `.cySkip` property on the story itself.\\\\\\\",\\\\n    },\\\\n  },\\\\n};\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\\\n  <Button {...args} label=\\\\\\\"Story function\\\\\\\" />\\\\n);\\\\n\\\\n/* istanbul ignore next */ // story-code @skip\\\\nSkippedFunction.cy = () =>\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\");\\\\nSkippedFunction.cySkip = true;\\\\n// story-code @end\\\\n\\\\nexport const Skipped = {\\\\n  ...NotSkipped,\\\\n  args: { label: \\\\\\\"Another\\\\\\\" },\\\\n  cy:\\\\n    /* istanbul ignore next */ // story-code @skip\\\\n    () => cy.dataCy(\\\\\\\"button\\\\\\\").should(\\\\\\\"contain\\\\\\\", \\\\\\\"Would fail if not skipped\\\\\\\"),\\\\n  cySkip: true,\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"not-skipped\\\":{\\\"startLoc\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":59,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"skipped-function\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":25},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":23},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":25}}}},}, component: Button };\\n\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);;\\n\\nNotSkipped.cy = () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkipped.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"You can skip individual stories via `.cySkip` property on the story itself.\\\",\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\nSkippedFunction.cySkip = true;\\n// story-code @end\\n\\nexport const Skipped = {\\n  ...NotSkipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n  cySkip: true,\\n};\\n\",\"locationsMap\":{\"not-skipped\":{\"startLoc\":{\"col\":59,\"line\":15},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":59,\"line\":15},\"endBody\":{\"col\":1,\"line\":17}},\"skipped-function\":{\"startLoc\":{\"col\":64,\"line\":31},\"endLoc\":{\"col\":1,\"line\":33},\"startBody\":{\"col\":64,\"line\":31},\"endBody\":{\"col\":1,\"line\":33}}}},\"storySource\":{\"source\":\"import React from \\\"react\\\";\\nimport type { ComponentStoryCy } from \\\"orphic-cypress\\\";\\nimport { Button } from \\\"stories\\\";\\n\\nexport default { component: Button };\\n\\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\nNotSkipped.cy = () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Story function\\\");\\n// story-code @end @include-default\\nNotSkipped.parameters = {\\n  docs: {\\n    description: {\\n      story:\\n        \\\"You can skip individual stories via `.cySkip` property on the story itself.\\\",\\n    },\\n  },\\n};\\n\\n/* istanbul ignore next */ // story-code @skip\\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\\n  <Button {...args} label=\\\"Story function\\\" />\\n);\\n\\n/* istanbul ignore next */ // story-code @skip\\nSkippedFunction.cy = () =>\\n  cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\");\\nSkippedFunction.cySkip = true;\\n// story-code @end\\n\\nexport const Skipped = {\\n  ...NotSkipped,\\n  args: { label: \\\"Another\\\" },\\n  cy:\\n    /* istanbul ignore next */ // story-code @skip\\n    () => cy.dataCy(\\\"button\\\").should(\\\"contain\\\", \\\"Would fail if not skipped\\\"),\\n  cySkip: true,\\n};\\n\",\"locationsMap\":{\"not-skipped\":{\"startLoc\":{\"col\":59,\"line\":7},\"endLoc\":{\"col\":1,\"line\":9},\"startBody\":{\"col\":59,\"line\":7},\"endBody\":{\"col\":1,\"line\":9}},\"skipped-function\":{\"startLoc\":{\"col\":64,\"line\":23},\"endLoc\":{\"col\":1,\"line\":25},\"startBody\":{\"col\":64,\"line\":23},\"endBody\":{\"col\":1,\"line\":25}}}},}, component: Button };\n\nexport const NotSkipped: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);;;\n\nNotSkipped.cy = () => cy.dataCy(\"button\").should(\"contain\", \"Story function\");\n// story-code @end @include-default\nNotSkipped.parameters = {\n  docs: {\n    description: {\n      story:\n        \"You can skip individual stories via `.cySkip` property on the story itself.\",\n    },\n  },\n};\n\n/* istanbul ignore next */ // story-code @skip\nexport const SkippedFunction: ComponentStoryCy<typeof Button> = (args) => (\n  <Button {...args} label=\"Story function\" />\n);\n\n/* istanbul ignore next */ // story-code @skip\nSkippedFunction.cy = () =>\n  cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\");\nSkippedFunction.cySkip = true;\n// story-code @end\n\nexport const Skipped = {\n  ...NotSkipped,\n  args: { label: \"Another\" },\n  cy:\n    /* istanbul ignore next */ // story-code @skip\n    () => cy.dataCy(\"button\").should(\"contain\", \"Would fail if not skipped\"),\n  cySkip: true,\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"../../Button\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  cySkip: true,\\\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\\\n  // parameters: {\\\\n  //   actions: {\\\\n  //     argTypesRegex: \\\\\\\"^on[A-Z].*\\\\\\\",\\\\n  //   },\\\\n  // },\\\\n};\\\\n\\\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\\\n  args\\\\n) => <ClickCount {...args} />;\\\\nArgtypeActionStub.argTypes = {\\\\n  onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n};\\\\n// story-code @end @include-start\\\\n\\\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: { label: \\\\\\\"Call via Regex\\\\\\\" },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"ArgtypeActionStub\\\":{\\\"startLoc\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endLoc\\\":{\\\"col\\\":29,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endBody\\\":{\\\"col\\\":29,\\\"line\\\":19}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"../../Button\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"../../Button\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  cySkip: true,\\\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\\\n  // parameters: {\\\\n  //   actions: {\\\\n  //     argTypesRegex: \\\\\\\"^on[A-Z].*\\\\\\\",\\\\n  //   },\\\\n  // },\\\\n};\\\\n\\\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\\\n  args\\\\n) => <ClickCount {...args} />;\\\\nArgtypeActionStub.argTypes = {\\\\n  onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n};\\\\n// story-code @end @include-start\\\\n\\\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: { label: \\\\\\\"Call via Regex\\\\\\\" },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"argtype-action-stub\\\":{\\\"startLoc\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endLoc\\\":{\\\"col\\\":29,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endBody\\\":{\\\"col\\\":29,\\\"line\\\":19}}}},},\\n  component: ClickCount,\\n  cySkip: true,\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\n  // parameters: {\\n  //   actions: {\\n  //     argTypesRegex: \\\"^on[A-Z].*\\\",\\n  //   },\\n  // },\\n};\\n\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\n  args\\n) => <ClickCount {...args} />;\\nArgtypeActionStub.argTypes = {\\n  onClick: { action: \\\"myClickStub\\\" },\\n};\\n// story-code @end @include-start\\n\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: { label: \\\"Call via Regex\\\" },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"ArgtypeActionStub\":{\"startLoc\":{\"col\":70,\"line\":25},\"endLoc\":{\"col\":29,\"line\":27},\"startBody\":{\"col\":70,\"line\":25},\"endBody\":{\"col\":29,\"line\":27}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"../../Button\\\";\\n\\nexport default {\\n  component: ClickCount,\\n  cySkip: true,\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\n  // parameters: {\\n  //   actions: {\\n  //     argTypesRegex: \\\"^on[A-Z].*\\\",\\n  //   },\\n  // },\\n};\\n\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\n  args\\n) => <ClickCount {...args} />;\\nArgtypeActionStub.argTypes = {\\n  onClick: { action: \\\"myClickStub\\\" },\\n};\\n// story-code @end @include-start\\n\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: { label: \\\"Call via Regex\\\" },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"ArgtypeActionStub\":{\"startLoc\":{\"col\":70,\"line\":17},\"endLoc\":{\"col\":29,\"line\":19},\"startBody\":{\"col\":70,\"line\":17},\"endBody\":{\"col\":29,\"line\":19}}};\n    \nimport React from \"react\";\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \"orphic-cypress\";\nimport { ClickCount } from \"../../Button\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"../../Button\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  cySkip: true,\\\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\\\n  // parameters: {\\\\n  //   actions: {\\\\n  //     argTypesRegex: \\\\\\\"^on[A-Z].*\\\\\\\",\\\\n  //   },\\\\n  // },\\\\n};\\\\n\\\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\\\n  args\\\\n) => <ClickCount {...args} />;\\\\nArgtypeActionStub.argTypes = {\\\\n  onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n};\\\\n// story-code @end @include-start\\\\n\\\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: { label: \\\\\\\"Call via Regex\\\\\\\" },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"ArgtypeActionStub\\\":{\\\"startLoc\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endLoc\\\":{\\\"col\\\":29,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endBody\\\":{\\\"col\\\":29,\\\"line\\\":19}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"../../Button\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"../../Button\\\\\\\";\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  cySkip: true,\\\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\\\n  // parameters: {\\\\n  //   actions: {\\\\n  //     argTypesRegex: \\\\\\\"^on[A-Z].*\\\\\\\",\\\\n  //   },\\\\n  // },\\\\n};\\\\n\\\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\\\n  args\\\\n) => <ClickCount {...args} />;\\\\nArgtypeActionStub.argTypes = {\\\\n  onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n};\\\\n// story-code @end @include-start\\\\n\\\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: { label: \\\\\\\"Call via Regex\\\\\\\" },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"argtype-action-stub\\\":{\\\"startLoc\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endLoc\\\":{\\\"col\\\":29,\\\"line\\\":19},\\\"startBody\\\":{\\\"col\\\":70,\\\"line\\\":17},\\\"endBody\\\":{\\\"col\\\":29,\\\"line\\\":19}}}},},\\n  component: ClickCount,\\n  cySkip: true,\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\n  // parameters: {\\n  //   actions: {\\n  //     argTypesRegex: \\\"^on[A-Z].*\\\",\\n  //   },\\n  // },\\n};\\n\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\n  args\\n) => <ClickCount {...args} />;\\nArgtypeActionStub.argTypes = {\\n  onClick: { action: \\\"myClickStub\\\" },\\n};\\n// story-code @end @include-start\\n\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: { label: \\\"Call via Regex\\\" },\\n};\\n\",\"locationsMap\":{\"argtype-action-stub\":{\"startLoc\":{\"col\":70,\"line\":25},\"endLoc\":{\"col\":29,\"line\":27},\"startBody\":{\"col\":70,\"line\":25},\"endBody\":{\"col\":29,\"line\":27}}}},\"storySource\":{\"source\":\"import React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"../../Button\\\";\\n\\nexport default {\\n  component: ClickCount,\\n  cySkip: true,\\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\\n  // so you either have to add this, or manually provide the global preview to `composeStories`\\n  // parameters: {\\n  //   actions: {\\n  //     argTypesRegex: \\\"^on[A-Z].*\\\",\\n  //   },\\n  // },\\n};\\n\\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\\n  args\\n) => <ClickCount {...args} />;\\nArgtypeActionStub.argTypes = {\\n  onClick: { action: \\\"myClickStub\\\" },\\n};\\n// story-code @end @include-start\\n\\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: { label: \\\"Call via Regex\\\" },\\n};\\n\",\"locationsMap\":{\"argtype-action-stub\":{\"startLoc\":{\"col\":70,\"line\":17},\"endLoc\":{\"col\":29,\"line\":19},\"startBody\":{\"col\":70,\"line\":17},\"endBody\":{\"col\":29,\"line\":19}}}},},\n  component: ClickCount,\n  cySkip: true,\n  // when using an external file, the argTypesRegex doesn't get brought in from main 'parameters'\n  // so you either have to add this, or manually provide the global preview to `composeStories`\n  // parameters: {\n  //   actions: {\n  //     argTypesRegex: \"^on[A-Z].*\",\n  //   },\n  // },\n};\n\nexport const ArgtypeActionStub: ComponentStoryCy<typeof ClickCount> = (\n  args\n) => <ClickCount {...args} />;\nArgtypeActionStub.argTypes = {\n  onClick: { action: \"myClickStub\" },\n};\n// story-code @end @include-start\n\nexport const ImplicitArgtypeActionStubViaRegex: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  args: { label: \"Call via Regex\" },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import type Sinon from \\\\\\\"cypress/types/sinon\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\n// With both of these, you'd probably just be passing in normal functions,\\\\n// but here we're spying for the sake of meta-test assertions.\\\\nconst hasCypress = Boolean((global as any).Cypress);\\\\nconst dumbFunction = () => 1;\\\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\\\n  hasCypress\\\\n    ? Cypress.sinon.spy(dumbFunction)\\\\n    : /* istanbul ignore next */ // story-code @skip\\\\n      dumbFunction\\\\n);\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  argTypes: {\\\\n    onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n  },\\\\n  args: {\\\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\\\n    onClick2: onClickSpy2,\\\\n  },\\\\n};\\\\n\\\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    // just arbitrarily using the nesting data-cy here, no particular need\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n    // arbitrarily trying the unlikely approach to dataCy\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n      cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n    );\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n    // name on actions is `onClick`\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // but the action string also functions as an alias\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // and if it would have come from argtypes regex as well, then\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n\\\\n    cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  },\\\\n};\\\\n// story-code @include-start\\\\n\\\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    onClick: onClickSpy,\\\\n  },\\\\n  cy: () => {\\\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n      .click()\\\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n    // And then the important thing: actions object wraps that provided function in a spy\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // still aliased as the argtype name as well and not from regex\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nSpyOnProvided.args = {\\\\n  onClick: onClickSpy,\\\\n};\\\\nSpyOnProvided.cy = () => {\\\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n};\\\\n// story-code @end SpyOnProvided\\\\n\\\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button-2\\\\\\\")\\\\n      .click()\\\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"SpyOnProvided\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":74},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":74}}};\\n    \\nimport type Sinon from \\\"cypress/types/sinon\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\n// With both of these, you'd probably just be passing in normal functions,\\n// but here we're spying for the sake of meta-test assertions.\\nconst hasCypress = Boolean((global as any).Cypress);\\nconst dumbFunction = () => 1;\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\n  hasCypress\\n    ? Cypress.sinon.spy(dumbFunction)\\n    : /* istanbul ignore next */ // story-code @skip\\n      dumbFunction\\n);\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import type Sinon from \\\\\\\"cypress/types/sinon\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\n// With both of these, you'd probably just be passing in normal functions,\\\\n// but here we're spying for the sake of meta-test assertions.\\\\nconst hasCypress = Boolean((global as any).Cypress);\\\\nconst dumbFunction = () => 1;\\\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\\\n  hasCypress\\\\n    ? Cypress.sinon.spy(dumbFunction)\\\\n    : /* istanbul ignore next */ // story-code @skip\\\\n      dumbFunction\\\\n);\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  argTypes: {\\\\n    onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n  },\\\\n  args: {\\\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\\\n    onClick2: onClickSpy2,\\\\n  },\\\\n};\\\\n\\\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    // just arbitrarily using the nesting data-cy here, no particular need\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n    // arbitrarily trying the unlikely approach to dataCy\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n      cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n    );\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n    // name on actions is `onClick`\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // but the action string also functions as an alias\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // and if it would have come from argtypes regex as well, then\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n\\\\n    cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  },\\\\n};\\\\n// story-code @include-start\\\\n\\\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    onClick: onClickSpy,\\\\n  },\\\\n  cy: () => {\\\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n      .click()\\\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n    // And then the important thing: actions object wraps that provided function in a spy\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // still aliased as the argtype name as well and not from regex\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nSpyOnProvided.args = {\\\\n  onClick: onClickSpy,\\\\n};\\\\nSpyOnProvided.cy = () => {\\\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n};\\\\n// story-code @end SpyOnProvided\\\\n\\\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button-2\\\\\\\")\\\\n      .click()\\\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"spy-on-provided\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":74},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":74}}}},},\\n  component: ClickCount,\\n  argTypes: {\\n    onClick: { action: \\\"myClickStub\\\" },\\n  },\\n  args: {\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\n    onClick2: onClickSpy2,\\n  },\\n};\\n\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    // just arbitrarily using the nesting data-cy here, no particular need\\n    cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n    // arbitrarily trying the unlikely approach to dataCy\\n    cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n      cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n    );\\n    cy.dataCy(\\\"button\\\").click();\\n\\n    // name on actions is `onClick`\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // but the action string also functions as an alias\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // and if it would have come from argtypes regex as well, then\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n\\n    cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  },\\n};\\n// story-code @include-start\\n\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    onClick: onClickSpy,\\n  },\\n  cy: () => {\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button\\\")\\n      .click()\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n    // And then the important thing: actions object wraps that provided function in a spy\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // still aliased as the argtype name as well and not from regex\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nSpyOnProvided.args = {\\n  onClick: onClickSpy,\\n};\\nSpyOnProvided.cy = () => {\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n};\\n// story-code @end SpyOnProvided\\n\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button-2\\\")\\n      .click()\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\n    cy.get(\\\"@actions\\\").its(\\\"onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\n    cy.get(\\\"@argTypesRegex.onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"SpyOnProvided\":{\"startLoc\":{\"col\":66,\"line\":80},\"endLoc\":{\"col\":1,\"line\":82},\"startBody\":{\"col\":66,\"line\":80},\"endBody\":{\"col\":1,\"line\":82}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import type Sinon from \\\"cypress/types/sinon\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\n// With both of these, you'd probably just be passing in normal functions,\\n// but here we're spying for the sake of meta-test assertions.\\nconst hasCypress = Boolean((global as any).Cypress);\\nconst dumbFunction = () => 1;\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\n  hasCypress\\n    ? Cypress.sinon.spy(dumbFunction)\\n    : /* istanbul ignore next */ // story-code @skip\\n      dumbFunction\\n);\\n\\nexport default {\\n  component: ClickCount,\\n  argTypes: {\\n    onClick: { action: \\\"myClickStub\\\" },\\n  },\\n  args: {\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\n    onClick2: onClickSpy2,\\n  },\\n};\\n\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    // just arbitrarily using the nesting data-cy here, no particular need\\n    cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n    // arbitrarily trying the unlikely approach to dataCy\\n    cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n      cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n    );\\n    cy.dataCy(\\\"button\\\").click();\\n\\n    // name on actions is `onClick`\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // but the action string also functions as an alias\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // and if it would have come from argtypes regex as well, then\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n\\n    cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  },\\n};\\n// story-code @include-start\\n\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    onClick: onClickSpy,\\n  },\\n  cy: () => {\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button\\\")\\n      .click()\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n    // And then the important thing: actions object wraps that provided function in a spy\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // still aliased as the argtype name as well and not from regex\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nSpyOnProvided.args = {\\n  onClick: onClickSpy,\\n};\\nSpyOnProvided.cy = () => {\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n};\\n// story-code @end SpyOnProvided\\n\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button-2\\\")\\n      .click()\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\n    cy.get(\\\"@actions\\\").its(\\\"onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\n    cy.get(\\\"@argTypesRegex.onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"SpyOnProvided\":{\"startLoc\":{\"col\":66,\"line\":72},\"endLoc\":{\"col\":1,\"line\":74},\"startBody\":{\"col\":66,\"line\":72},\"endBody\":{\"col\":1,\"line\":74}}};\n    \nimport type Sinon from \"cypress/types/sinon\";\nimport React from \"react\";\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \"orphic-cypress\";\nimport { ClickCount } from \"stories\";\n\n// With both of these, you'd probably just be passing in normal functions,\n// but here we're spying for the sake of meta-test assertions.\nconst hasCypress = Boolean((global as any).Cypress);\nconst dumbFunction = () => 1;\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\n  hasCypress\n    ? Cypress.sinon.spy(dumbFunction)\n    : /* istanbul ignore next */ // story-code @skip\n      dumbFunction\n);\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import type Sinon from \\\\\\\"cypress/types/sinon\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\n// With both of these, you'd probably just be passing in normal functions,\\\\n// but here we're spying for the sake of meta-test assertions.\\\\nconst hasCypress = Boolean((global as any).Cypress);\\\\nconst dumbFunction = () => 1;\\\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\\\n  hasCypress\\\\n    ? Cypress.sinon.spy(dumbFunction)\\\\n    : /* istanbul ignore next */ // story-code @skip\\\\n      dumbFunction\\\\n);\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  argTypes: {\\\\n    onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n  },\\\\n  args: {\\\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\\\n    onClick2: onClickSpy2,\\\\n  },\\\\n};\\\\n\\\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    // just arbitrarily using the nesting data-cy here, no particular need\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n    // arbitrarily trying the unlikely approach to dataCy\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n      cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n    );\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n    // name on actions is `onClick`\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // but the action string also functions as an alias\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // and if it would have come from argtypes regex as well, then\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n\\\\n    cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  },\\\\n};\\\\n// story-code @include-start\\\\n\\\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    onClick: onClickSpy,\\\\n  },\\\\n  cy: () => {\\\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n      .click()\\\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n    // And then the important thing: actions object wraps that provided function in a spy\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // still aliased as the argtype name as well and not from regex\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nSpyOnProvided.args = {\\\\n  onClick: onClickSpy,\\\\n};\\\\nSpyOnProvided.cy = () => {\\\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n};\\\\n// story-code @end SpyOnProvided\\\\n\\\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button-2\\\\\\\")\\\\n      .click()\\\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"SpyOnProvided\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":74},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":74}}};\\n    \\nimport type Sinon from \\\"cypress/types/sinon\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\n// With both of these, you'd probably just be passing in normal functions,\\n// but here we're spying for the sake of meta-test assertions.\\nconst hasCypress = Boolean((global as any).Cypress);\\nconst dumbFunction = () => 1;\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\n  hasCypress\\n    ? Cypress.sinon.spy(dumbFunction)\\n    : /* istanbul ignore next */ // story-code @skip\\n      dumbFunction\\n);\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import type Sinon from \\\\\\\"cypress/types/sinon\\\\\\\";\\\\nimport React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\n// With both of these, you'd probably just be passing in normal functions,\\\\n// but here we're spying for the sake of meta-test assertions.\\\\nconst hasCypress = Boolean((global as any).Cypress);\\\\nconst dumbFunction = () => 1;\\\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\\\n  hasCypress\\\\n    ? Cypress.sinon.spy(dumbFunction)\\\\n    : /* istanbul ignore next */ // story-code @skip\\\\n      dumbFunction\\\\n);\\\\n\\\\nexport default {\\\\n  component: ClickCount,\\\\n  argTypes: {\\\\n    onClick: { action: \\\\\\\"myClickStub\\\\\\\" },\\\\n  },\\\\n  args: {\\\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\\\n    onClick2: onClickSpy2,\\\\n  },\\\\n};\\\\n\\\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    // just arbitrarily using the nesting data-cy here, no particular need\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n    // arbitrarily trying the unlikely approach to dataCy\\\\n    cy.dataCy(\\\\\\\"click-container\\\\\\\").then(($clickContainer) =>\\\\n      cy.dataCy($clickContainer, \\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0)\\\\n    );\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n    // name on actions is `onClick`\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // but the action string also functions as an alias\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // and if it would have come from argtypes regex as well, then\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n\\\\n    cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  },\\\\n};\\\\n// story-code @include-start\\\\n\\\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    onClick: onClickSpy,\\\\n  },\\\\n  cy: () => {\\\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n      .click()\\\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n    // And then the important thing: actions object wraps that provided function in a spy\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // still aliased as the argtype name as well and not from regex\\\\n    cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nSpyOnProvided.args = {\\\\n  onClick: onClickSpy,\\\\n};\\\\nSpyOnProvided.cy = () => {\\\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@myClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n};\\\\n// story-code @end SpyOnProvided\\\\n\\\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cy: () => {\\\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\\\n    cy.dataCy(\\\\\\\"button-2\\\\\\\")\\\\n      .click()\\\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\\\n    cy.get(\\\\\\\"@argTypesRegex.onClick2\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"spy-on-provided\\\":{\\\"startLoc\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":74},\\\"startBody\\\":{\\\"col\\\":66,\\\"line\\\":72},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":74}}}},},\\n  component: ClickCount,\\n  argTypes: {\\n    onClick: { action: \\\"myClickStub\\\" },\\n  },\\n  args: {\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\n    onClick2: onClickSpy2,\\n  },\\n};\\n\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    // just arbitrarily using the nesting data-cy here, no particular need\\n    cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n    // arbitrarily trying the unlikely approach to dataCy\\n    cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n      cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n    );\\n    cy.dataCy(\\\"button\\\").click();\\n\\n    // name on actions is `onClick`\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // but the action string also functions as an alias\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // and if it would have come from argtypes regex as well, then\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n\\n    cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  },\\n};\\n// story-code @include-start\\n\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    onClick: onClickSpy,\\n  },\\n  cy: () => {\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button\\\")\\n      .click()\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n    // And then the important thing: actions object wraps that provided function in a spy\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // still aliased as the argtype name as well and not from regex\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nSpyOnProvided.args = {\\n  onClick: onClickSpy,\\n};\\nSpyOnProvided.cy = () => {\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n};\\n// story-code @end SpyOnProvided\\n\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button-2\\\")\\n      .click()\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\n    cy.get(\\\"@actions\\\").its(\\\"onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\n    cy.get(\\\"@argTypesRegex.onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\",\"locationsMap\":{\"spy-on-provided\":{\"startLoc\":{\"col\":66,\"line\":80},\"endLoc\":{\"col\":1,\"line\":82},\"startBody\":{\"col\":66,\"line\":80},\"endBody\":{\"col\":1,\"line\":82}}}},\"storySource\":{\"source\":\"import type Sinon from \\\"cypress/types/sinon\\\";\\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\n// With both of these, you'd probably just be passing in normal functions,\\n// but here we're spying for the sake of meta-test assertions.\\nconst hasCypress = Boolean((global as any).Cypress);\\nconst dumbFunction = () => 1;\\nconst [onClickSpy, onClickSpy2] = [...Array(2).keys()].map(() =>\\n  hasCypress\\n    ? Cypress.sinon.spy(dumbFunction)\\n    : /* istanbul ignore next */ // story-code @skip\\n      dumbFunction\\n);\\n\\nexport default {\\n  component: ClickCount,\\n  argTypes: {\\n    onClick: { action: \\\"myClickStub\\\" },\\n  },\\n  args: {\\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\\n    onClick2: onClickSpy2,\\n  },\\n};\\n\\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    // just arbitrarily using the nesting data-cy here, no particular need\\n    cy.dataCy(\\\"click-container\\\").dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n    // arbitrarily trying the unlikely approach to dataCy\\n    cy.dataCy(\\\"click-container\\\").then(($clickContainer) =>\\n      cy.dataCy($clickContainer, \\\"count\\\").should(\\\"contain\\\", 0)\\n    );\\n    cy.dataCy(\\\"button\\\").click();\\n\\n    // name on actions is `onClick`\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // but the action string also functions as an alias\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // and if it would have come from argtypes regex as well, then\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n\\n    cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  },\\n};\\n// story-code @include-start\\n\\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    onClick: onClickSpy,\\n  },\\n  cy: () => {\\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button\\\")\\n      .click()\\n      // So the spy itself is already called (you'd probably just provide a normal function)\\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n    // And then the important thing: actions object wraps that provided function in a spy\\n    cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // still aliased as the argtype name as well and not from regex\\n    cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nSpyOnProvided.args = {\\n  onClick: onClickSpy,\\n};\\nSpyOnProvided.cy = () => {\\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@myClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n};\\n// story-code @end SpyOnProvided\\n\\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cy: () => {\\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\\n    cy.dataCy(\\\"button-2\\\")\\n      .click()\\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\\n    cy.get(\\\"@actions\\\").its(\\\"onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\\n    cy.get(\\\"@argTypesRegex.onClick2\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  },\\n};\\n\",\"locationsMap\":{\"spy-on-provided\":{\"startLoc\":{\"col\":66,\"line\":72},\"endLoc\":{\"col\":1,\"line\":74},\"startBody\":{\"col\":66,\"line\":72},\"endBody\":{\"col\":1,\"line\":74}}}},},\n  component: ClickCount,\n  argTypes: {\n    onClick: { action: \"myClickStub\" },\n  },\n  args: {\n    // not tested until SpyOnArgsWhichAreProvidedInDefaultExport\n    onClick2: onClickSpy2,\n  },\n};\n\nexport const StubActionsDefinedOnDefaultExport: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  cy: () => {\n    // just arbitrarily using the nesting data-cy here, no particular need\n    cy.dataCy(\"click-container\").dataCy(\"count\").should(\"contain\", 0);\n    // arbitrarily trying the unlikely approach to dataCy\n    cy.dataCy(\"click-container\").then(($clickContainer) =>\n      cy.dataCy($clickContainer, \"count\").should(\"contain\", 0)\n    );\n    cy.dataCy(\"button\").click();\n\n    // name on actions is `onClick`\n    cy.get(\"@actions\").its(\"onClick\").should(\"be.calledOnceWith\", 0);\n    // but the action string also functions as an alias\n    cy.get(\"@myClickStub\").should(\"be.calledOnceWith\", 0);\n    // and if it would have come from argtypes regex as well, then\n    cy.get(\"@argTypesRegex.onClick\").should(\"be.calledOnceWith\", 0);\n\n    cy.dataCy(\"count\").should(\"contain\", 1);\n  },\n};\n// story-code @include-start\n\nexport const SpyOnArgsWhichAreAlreadyProvided: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  args: {\n    onClick: onClickSpy,\n  },\n  cy: () => {\n    (onClickSpy as Sinon.SinonSpy).resetHistory();\n    cy.dataCy(\"button\")\n      .click()\n      // So the spy itself is already called (you'd probably just provide a normal function)\n      .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\n    // And then the important thing: actions object wraps that provided function in a spy\n    cy.get(\"@actions\").its(\"onClick\").should(\"be.calledOnceWith\", 0);\n    // still aliased as the argtype name as well and not from regex\n    cy.get(\"@myClickStub\").should(\"be.calledOnceWith\", 0);\n    cy.get(\"@argTypesRegex.onClick\").should(\"be.calledOnceWith\", 0);\n  },\n};\n\nexport const SpyOnProvided: ComponentStoryCy<typeof ClickCount> = (args) => (\n  <ClickCount {...args} />\n);\nSpyOnProvided.args = {\n  onClick: onClickSpy,\n};\nSpyOnProvided.cy = () => {\n  (onClickSpy as Sinon.SinonSpy).resetHistory();\n  cy.dataCy(\"button\")\n    .click()\n    .then(() => expect(onClickSpy).to.be.calledOnceWith(0));\n  cy.get(\"@actions\").its(\"onClick\").should(\"be.calledOnceWith\", 0);\n  cy.get(\"@myClickStub\").should(\"be.calledOnceWith\", 0);\n  cy.get(\"@argTypesRegex.onClick\").should(\"be.calledOnceWith\", 0);\n};\n// story-code @end SpyOnProvided\n\nexport const SpyOnArgsWhichAreProvidedInDefaultExport: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  cy: () => {\n    (onClickSpy2 as Sinon.SinonSpy).resetHistory();\n    cy.dataCy(\"button-2\")\n      .click()\n      .then(() => expect(onClickSpy2).to.be.calledOnceWith(0));\n    cy.get(\"@actions\").its(\"onClick2\").should(\"be.calledOnceWith\", 0);\n    // No argTypes provided for onClick2, so this goes to the argTypesRegex generated stub\n    cy.get(\"@argTypesRegex.onClick2\").should(\"be.calledOnceWith\", 0);\n  },\n};\n","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: ClickCount };\\\\n\\\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nStubActions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n  onClick2: { action: \\\\\\\"onClick2Stub\\\\\\\" },\\\\n};\\\\nStubActions.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 2).and(\\\\\\\"be.calledWith\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button-2\\\\\\\").click().click().click();\\\\n  cy.get(\\\\\\\"@onClick2Stub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 3);\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\\\n  typeof ClickCount\\\\n> = (args) => <ClickCount {...args} />;\\\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n};\\\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n  // name on actions is `onClick`\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // but the action string also functions as an alias\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledWith\\\\\\\", 0);\\\\n\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => {\\\\n      // just proving that `this` access works\\\\n      const self = this as any;\\\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self[\\\\\\\"argTypesRegex.onClick\\\\\\\"])\\\\n        .to.have.callCount(2)\\\\n        .and.be.calledWith(1);\\\\n      cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 2);\\\\n    });\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\\\n  cy: {\\\\n    \\\\\\\"should stub via argtype regex when no other reasons for stubbing exist\\\\\\\":\\\\n      function () {\\\\n        cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n          .click()\\\\n          .then(() => {\\\\n            // confirming that `this` access also works\\\\n            // @ts-ignore\\\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\\\n          });\\\\n        cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n        cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n      },\\\\n  },\\\\n};\\\\n\\\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cyTest: (Story) => {\\\\n    beforeEach(() => {\\\\n      cy.spy(() => 1).as(\\\\\\\"beforeEachSpy\\\\\\\");\\\\n    });\\\\n\\\\n    it(\\\\\\\"should call the spy and not the argTypesRegex stub\\\\\\\", function () {\\\\n      // could be alias syntax, but showing variant\\\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\\\n      cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n        .click()\\\\n        .then(() => {\\\\n          expect(this.actions.onClick).to.have.callCount(0);\\\\n          expect(this[\\\\\\\"argTypesRegex.onClick\\\\\\\"]).to.have.callCount(0);\\\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\\\n        });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    // @ts-ignore\\\\n    onSomethingElse:\\\\n      /* istanbul ignore next */ // story-code @skip\\\\n      () => 1,\\\\n  },\\\\n  cy: () => {\\\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@argTypesRegex.onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\\\nwithout docgen`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  argTypes: {\\\\n    // @ts-ignore\\\\n    onSomethingElse: { action: \\\\\\\"onSomethingElseAlias\\\\\\\" },\\\\n  },\\\\n  cy: () => {\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@onSomethingElseAlias\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"StubActions\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"CheckOtherAliasesAndAccessOptions\\\":{\\\"startLoc\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endLoc\\\":{\\\"col\\\":38,\\\"line\\\":28},\\\"startBody\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endBody\\\":{\\\"col\\\":38,\\\"line\\\":28}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: ClickCount };\\\\n\\\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nStubActions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n  onClick2: { action: \\\\\\\"onClick2Stub\\\\\\\" },\\\\n};\\\\nStubActions.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 2).and(\\\\\\\"be.calledWith\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button-2\\\\\\\").click().click().click();\\\\n  cy.get(\\\\\\\"@onClick2Stub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 3);\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\\\n  typeof ClickCount\\\\n> = (args) => <ClickCount {...args} />;\\\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n};\\\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n  // name on actions is `onClick`\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // but the action string also functions as an alias\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledWith\\\\\\\", 0);\\\\n\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => {\\\\n      // just proving that `this` access works\\\\n      const self = this as any;\\\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self[\\\\\\\"argTypesRegex.onClick\\\\\\\"])\\\\n        .to.have.callCount(2)\\\\n        .and.be.calledWith(1);\\\\n      cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 2);\\\\n    });\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\\\n  cy: {\\\\n    \\\\\\\"should stub via argtype regex when no other reasons for stubbing exist\\\\\\\":\\\\n      function () {\\\\n        cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n          .click()\\\\n          .then(() => {\\\\n            // confirming that `this` access also works\\\\n            // @ts-ignore\\\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\\\n          });\\\\n        cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n        cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n      },\\\\n  },\\\\n};\\\\n\\\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cyTest: (Story) => {\\\\n    beforeEach(() => {\\\\n      cy.spy(() => 1).as(\\\\\\\"beforeEachSpy\\\\\\\");\\\\n    });\\\\n\\\\n    it(\\\\\\\"should call the spy and not the argTypesRegex stub\\\\\\\", function () {\\\\n      // could be alias syntax, but showing variant\\\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\\\n      cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n        .click()\\\\n        .then(() => {\\\\n          expect(this.actions.onClick).to.have.callCount(0);\\\\n          expect(this[\\\\\\\"argTypesRegex.onClick\\\\\\\"]).to.have.callCount(0);\\\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\\\n        });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    // @ts-ignore\\\\n    onSomethingElse:\\\\n      /* istanbul ignore next */ // story-code @skip\\\\n      () => 1,\\\\n  },\\\\n  cy: () => {\\\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@argTypesRegex.onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\\\nwithout docgen`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  argTypes: {\\\\n    // @ts-ignore\\\\n    onSomethingElse: { action: \\\\\\\"onSomethingElseAlias\\\\\\\" },\\\\n  },\\\\n  cy: () => {\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@onSomethingElseAlias\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"stub-actions\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"check-other-aliases-and-access-options\\\":{\\\"startLoc\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endLoc\\\":{\\\"col\\\":38,\\\"line\\\":28},\\\"startBody\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endBody\\\":{\\\"col\\\":38,\\\"line\\\":28}}}},}, component: ClickCount };\\n\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);;\\nStubActions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n  onClick2: { action: \\\"onClick2Stub\\\" },\\n};\\nStubActions.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"have.callCount\\\", 2).and(\\\"be.calledWith\\\", 1);\\n  cy.dataCy(\\\"button-2\\\").click().click().click();\\n  cy.get(\\\"@onClick2Stub\\\").should(\\\"have.callCount\\\", 3);\\n};\\n// story-code @end\\n\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\n  typeof ClickCount\\n> = (args) => <ClickCount {...args} />;\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n};\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n\\n  // name on actions is `onClick`\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // but the action string also functions as an alias\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledWith\\\", 0);\\n\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => {\\n      // just proving that `this` access works\\n      const self = this as any;\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self[\\\"argTypesRegex.onClick\\\"])\\n        .to.have.callCount(2)\\n        .and.be.calledWith(1);\\n      cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 2);\\n    });\\n};\\n// story-code @end\\n\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\n  cy: {\\n    \\\"should stub via argtype regex when no other reasons for stubbing exist\\\":\\n      function () {\\n        cy.dataCy(\\\"button\\\")\\n          .click()\\n          .then(() => {\\n            // confirming that `this` access also works\\n            // @ts-ignore\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\n          });\\n        cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n        cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n      },\\n  },\\n};\\n\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cyTest: (Story) => {\\n    beforeEach(() => {\\n      cy.spy(() => 1).as(\\\"beforeEachSpy\\\");\\n    });\\n\\n    it(\\\"should call the spy and not the argTypesRegex stub\\\", function () {\\n      // could be alias syntax, but showing variant\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\n      cy.dataCy(\\\"button\\\")\\n        .click()\\n        .then(() => {\\n          expect(this.actions.onClick).to.have.callCount(0);\\n          expect(this[\\\"argTypesRegex.onClick\\\"]).to.have.callCount(0);\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\n        });\\n    });\\n  },\\n};\\n\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    // @ts-ignore\\n    onSomethingElse:\\n      /* istanbul ignore next */ // story-code @skip\\n      () => 1,\\n  },\\n  cy: () => {\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@argTypesRegex.onSomethingElse\\\").should(\\\"not.be.called\\\");\\n  },\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\nwithout docgen`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  argTypes: {\\n    // @ts-ignore\\n    onSomethingElse: { action: \\\"onSomethingElseAlias\\\" },\\n  },\\n  cy: () => {\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@onSomethingElseAlias\\\").should(\\\"not.be.called\\\");\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"StubActions\":{\"startLoc\":{\"col\":64,\"line\":15},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":64,\"line\":15},\"endBody\":{\"col\":1,\"line\":17}},\"CheckOtherAliasesAndAccessOptions\":{\"startLoc\":{\"col\":4,\"line\":36},\"endLoc\":{\"col\":38,\"line\":36},\"startBody\":{\"col\":4,\"line\":36},\"endBody\":{\"col\":38,\"line\":36}}};\n    \n\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\nexport default { component: ClickCount };\\n\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nStubActions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n  onClick2: { action: \\\"onClick2Stub\\\" },\\n};\\nStubActions.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"have.callCount\\\", 2).and(\\\"be.calledWith\\\", 1);\\n  cy.dataCy(\\\"button-2\\\").click().click().click();\\n  cy.get(\\\"@onClick2Stub\\\").should(\\\"have.callCount\\\", 3);\\n};\\n// story-code @end\\n\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\n  typeof ClickCount\\n> = (args) => <ClickCount {...args} />;\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n};\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n\\n  // name on actions is `onClick`\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // but the action string also functions as an alias\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledWith\\\", 0);\\n\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => {\\n      // just proving that `this` access works\\n      const self = this as any;\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self[\\\"argTypesRegex.onClick\\\"])\\n        .to.have.callCount(2)\\n        .and.be.calledWith(1);\\n      cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 2);\\n    });\\n};\\n// story-code @end\\n\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\n  cy: {\\n    \\\"should stub via argtype regex when no other reasons for stubbing exist\\\":\\n      function () {\\n        cy.dataCy(\\\"button\\\")\\n          .click()\\n          .then(() => {\\n            // confirming that `this` access also works\\n            // @ts-ignore\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\n          });\\n        cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n        cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n      },\\n  },\\n};\\n\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cyTest: (Story) => {\\n    beforeEach(() => {\\n      cy.spy(() => 1).as(\\\"beforeEachSpy\\\");\\n    });\\n\\n    it(\\\"should call the spy and not the argTypesRegex stub\\\", function () {\\n      // could be alias syntax, but showing variant\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\n      cy.dataCy(\\\"button\\\")\\n        .click()\\n        .then(() => {\\n          expect(this.actions.onClick).to.have.callCount(0);\\n          expect(this[\\\"argTypesRegex.onClick\\\"]).to.have.callCount(0);\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\n        });\\n    });\\n  },\\n};\\n\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    // @ts-ignore\\n    onSomethingElse:\\n      /* istanbul ignore next */ // story-code @skip\\n      () => 1,\\n  },\\n  cy: () => {\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@argTypesRegex.onSomethingElse\\\").should(\\\"not.be.called\\\");\\n  },\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\nwithout docgen`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  argTypes: {\\n    // @ts-ignore\\n    onSomethingElse: { action: \\\"onSomethingElseAlias\\\" },\\n  },\\n  cy: () => {\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@onSomethingElseAlias\\\").should(\\\"not.be.called\\\");\\n  },\\n};\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"StubActions\":{\"startLoc\":{\"col\":64,\"line\":7},\"endLoc\":{\"col\":1,\"line\":9},\"startBody\":{\"col\":64,\"line\":7},\"endBody\":{\"col\":1,\"line\":9}},\"CheckOtherAliasesAndAccessOptions\":{\"startLoc\":{\"col\":4,\"line\":28},\"endLoc\":{\"col\":38,\"line\":28},\"startBody\":{\"col\":4,\"line\":28},\"endBody\":{\"col\":38,\"line\":28}}};\n    \nimport React from \"react\";\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \"orphic-cypress\";\nimport { ClickCount } from \"stories\";\n\nexport default {parameters: {\"storySource\":{\"source\":\"\\n    \\n    // @ts-nocheck\\n    // @ts-ignore\\n    var __STORY__ = \\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: ClickCount };\\\\n\\\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nStubActions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n  onClick2: { action: \\\\\\\"onClick2Stub\\\\\\\" },\\\\n};\\\\nStubActions.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 2).and(\\\\\\\"be.calledWith\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button-2\\\\\\\").click().click().click();\\\\n  cy.get(\\\\\\\"@onClick2Stub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 3);\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\\\n  typeof ClickCount\\\\n> = (args) => <ClickCount {...args} />;\\\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n};\\\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n  // name on actions is `onClick`\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // but the action string also functions as an alias\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledWith\\\\\\\", 0);\\\\n\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => {\\\\n      // just proving that `this` access works\\\\n      const self = this as any;\\\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self[\\\\\\\"argTypesRegex.onClick\\\\\\\"])\\\\n        .to.have.callCount(2)\\\\n        .and.be.calledWith(1);\\\\n      cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 2);\\\\n    });\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\\\n  cy: {\\\\n    \\\\\\\"should stub via argtype regex when no other reasons for stubbing exist\\\\\\\":\\\\n      function () {\\\\n        cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n          .click()\\\\n          .then(() => {\\\\n            // confirming that `this` access also works\\\\n            // @ts-ignore\\\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\\\n          });\\\\n        cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n        cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n      },\\\\n  },\\\\n};\\\\n\\\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cyTest: (Story) => {\\\\n    beforeEach(() => {\\\\n      cy.spy(() => 1).as(\\\\\\\"beforeEachSpy\\\\\\\");\\\\n    });\\\\n\\\\n    it(\\\\\\\"should call the spy and not the argTypesRegex stub\\\\\\\", function () {\\\\n      // could be alias syntax, but showing variant\\\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\\\n      cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n        .click()\\\\n        .then(() => {\\\\n          expect(this.actions.onClick).to.have.callCount(0);\\\\n          expect(this[\\\\\\\"argTypesRegex.onClick\\\\\\\"]).to.have.callCount(0);\\\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\\\n        });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    // @ts-ignore\\\\n    onSomethingElse:\\\\n      /* istanbul ignore next */ // story-code @skip\\\\n      () => 1,\\\\n  },\\\\n  cy: () => {\\\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@argTypesRegex.onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\\\nwithout docgen`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  argTypes: {\\\\n    // @ts-ignore\\\\n    onSomethingElse: { action: \\\\\\\"onSomethingElseAlias\\\\\\\" },\\\\n  },\\\\n  cy: () => {\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@onSomethingElseAlias\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n};\\\\n\\\";\\n    // @ts-ignore\\n    var __LOCATIONS_MAP__ = {\\\"StubActions\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"CheckOtherAliasesAndAccessOptions\\\":{\\\"startLoc\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endLoc\\\":{\\\"col\\\":38,\\\"line\\\":28},\\\"startBody\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endBody\\\":{\\\"col\\\":38,\\\"line\\\":28}}};\\n    \\nimport React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\nexport default {parameters: {\\\"storySource\\\":{\\\"source\\\":\\\"import React from \\\\\\\"react\\\\\\\";\\\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\\\\\"orphic-cypress\\\\\\\";\\\\nimport { ClickCount } from \\\\\\\"stories\\\\\\\";\\\\n\\\\nexport default { component: ClickCount };\\\\n\\\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\\\n  <ClickCount {...args} />\\\\n);\\\\nStubActions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n  onClick2: { action: \\\\\\\"onClick2Stub\\\\\\\" },\\\\n};\\\\nStubActions.cy = () => {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 2).and(\\\\\\\"be.calledWith\\\\\\\", 1);\\\\n  cy.dataCy(\\\\\\\"button-2\\\\\\\").click().click().click();\\\\n  cy.get(\\\\\\\"@onClick2Stub\\\\\\\").should(\\\\\\\"have.callCount\\\\\\\", 3);\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\\\n  typeof ClickCount\\\\n> = (args) => <ClickCount {...args} />;\\\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\\\n  onClick: { action: \\\\\\\"onClickStub\\\\\\\" },\\\\n};\\\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 0);\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\").click();\\\\n\\\\n  // name on actions is `onClick`\\\\n  cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // but the action string also functions as an alias\\\\n  cy.get(\\\\\\\"@onClickStub\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\\\n  cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledWith\\\\\\\", 0);\\\\n\\\\n  cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 1);\\\\n\\\\n  cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n    .click()\\\\n    .then(() => {\\\\n      // just proving that `this` access works\\\\n      const self = this as any;\\\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\\\n      expect(self[\\\\\\\"argTypesRegex.onClick\\\\\\\"])\\\\n        .to.have.callCount(2)\\\\n        .and.be.calledWith(1);\\\\n      cy.dataCy(\\\\\\\"count\\\\\\\").should(\\\\\\\"contain\\\\\\\", 2);\\\\n    });\\\\n};\\\\n// story-code @end\\\\n\\\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\\\n  cy: {\\\\n    \\\\\\\"should stub via argtype regex when no other reasons for stubbing exist\\\\\\\":\\\\n      function () {\\\\n        cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n          .click()\\\\n          .then(() => {\\\\n            // confirming that `this` access also works\\\\n            // @ts-ignore\\\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\\\n          });\\\\n        cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n        cy.get(\\\\\\\"@argTypesRegex.onClick\\\\\\\").should(\\\\\\\"be.calledOnceWith\\\\\\\", 0);\\\\n      },\\\\n  },\\\\n};\\\\n\\\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  cyTest: (Story) => {\\\\n    beforeEach(() => {\\\\n      cy.spy(() => 1).as(\\\\\\\"beforeEachSpy\\\\\\\");\\\\n    });\\\\n\\\\n    it(\\\\\\\"should call the spy and not the argTypesRegex stub\\\\\\\", function () {\\\\n      // could be alias syntax, but showing variant\\\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\\\n      cy.dataCy(\\\\\\\"button\\\\\\\")\\\\n        .click()\\\\n        .then(() => {\\\\n          expect(this.actions.onClick).to.have.callCount(0);\\\\n          expect(this[\\\\\\\"argTypesRegex.onClick\\\\\\\"]).to.have.callCount(0);\\\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\\\n        });\\\\n    });\\\\n  },\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  args: {\\\\n    // @ts-ignore\\\\n    onSomethingElse:\\\\n      /* istanbul ignore next */ // story-code @skip\\\\n      () => 1,\\\\n  },\\\\n  cy: () => {\\\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@argTypesRegex.onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n  // story-code @skip-start\\\\n  parameters: {\\\\n    docs: {\\\\n      description: {\\\\n        story: `\\\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\\\nwithout docgen`,\\\\n      },\\\\n    },\\\\n  },\\\\n  // story-code @skip-end\\\\n};\\\\n\\\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\\\n  typeof ClickCount\\\\n> = {\\\\n  argTypes: {\\\\n    // @ts-ignore\\\\n    onSomethingElse: { action: \\\\\\\"onSomethingElseAlias\\\\\\\" },\\\\n  },\\\\n  cy: () => {\\\\n    cy.get(\\\\\\\"@actions\\\\\\\").its(\\\\\\\"onSomethingElse\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n    cy.get(\\\\\\\"@onSomethingElseAlias\\\\\\\").should(\\\\\\\"not.be.called\\\\\\\");\\\\n  },\\\\n};\\\\n\\\",\\\"locationsMap\\\":{\\\"stub-actions\\\":{\\\"startLoc\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endLoc\\\":{\\\"col\\\":1,\\\"line\\\":9},\\\"startBody\\\":{\\\"col\\\":64,\\\"line\\\":7},\\\"endBody\\\":{\\\"col\\\":1,\\\"line\\\":9}},\\\"check-other-aliases-and-access-options\\\":{\\\"startLoc\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endLoc\\\":{\\\"col\\\":38,\\\"line\\\":28},\\\"startBody\\\":{\\\"col\\\":4,\\\"line\\\":28},\\\"endBody\\\":{\\\"col\\\":38,\\\"line\\\":28}}}},}, component: ClickCount };\\n\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);;\\nStubActions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n  onClick2: { action: \\\"onClick2Stub\\\" },\\n};\\nStubActions.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"have.callCount\\\", 2).and(\\\"be.calledWith\\\", 1);\\n  cy.dataCy(\\\"button-2\\\").click().click().click();\\n  cy.get(\\\"@onClick2Stub\\\").should(\\\"have.callCount\\\", 3);\\n};\\n// story-code @end\\n\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\n  typeof ClickCount\\n> = (args) => <ClickCount {...args} />;\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n};\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n\\n  // name on actions is `onClick`\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // but the action string also functions as an alias\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledWith\\\", 0);\\n\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => {\\n      // just proving that `this` access works\\n      const self = this as any;\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self[\\\"argTypesRegex.onClick\\\"])\\n        .to.have.callCount(2)\\n        .and.be.calledWith(1);\\n      cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 2);\\n    });\\n};\\n// story-code @end\\n\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\n  cy: {\\n    \\\"should stub via argtype regex when no other reasons for stubbing exist\\\":\\n      function () {\\n        cy.dataCy(\\\"button\\\")\\n          .click()\\n          .then(() => {\\n            // confirming that `this` access also works\\n            // @ts-ignore\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\n          });\\n        cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n        cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n      },\\n  },\\n};\\n\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cyTest: (Story) => {\\n    beforeEach(() => {\\n      cy.spy(() => 1).as(\\\"beforeEachSpy\\\");\\n    });\\n\\n    it(\\\"should call the spy and not the argTypesRegex stub\\\", function () {\\n      // could be alias syntax, but showing variant\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\n      cy.dataCy(\\\"button\\\")\\n        .click()\\n        .then(() => {\\n          expect(this.actions.onClick).to.have.callCount(0);\\n          expect(this[\\\"argTypesRegex.onClick\\\"]).to.have.callCount(0);\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\n        });\\n    });\\n  },\\n};\\n\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    // @ts-ignore\\n    onSomethingElse:\\n      /* istanbul ignore next */ // story-code @skip\\n      () => 1,\\n  },\\n  cy: () => {\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@argTypesRegex.onSomethingElse\\\").should(\\\"not.be.called\\\");\\n  },\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\nwithout docgen`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  argTypes: {\\n    // @ts-ignore\\n    onSomethingElse: { action: \\\"onSomethingElseAlias\\\" },\\n  },\\n  cy: () => {\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@onSomethingElseAlias\\\").should(\\\"not.be.called\\\");\\n  },\\n};\\n\",\"locationsMap\":{\"stub-actions\":{\"startLoc\":{\"col\":64,\"line\":15},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":64,\"line\":15},\"endBody\":{\"col\":1,\"line\":17}},\"check-other-aliases-and-access-options\":{\"startLoc\":{\"col\":4,\"line\":36},\"endLoc\":{\"col\":38,\"line\":36},\"startBody\":{\"col\":4,\"line\":36},\"endBody\":{\"col\":38,\"line\":36}}}},\"storySource\":{\"source\":\"import React from \\\"react\\\";\\nimport type { ComponentStoryCy, ComponentStoryObjCy } from \\\"orphic-cypress\\\";\\nimport { ClickCount } from \\\"stories\\\";\\n\\nexport default { component: ClickCount };\\n\\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\\n  <ClickCount {...args} />\\n);\\nStubActions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n  onClick2: { action: \\\"onClick2Stub\\\" },\\n};\\nStubActions.cy = () => {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n  cy.dataCy(\\\"button\\\").click();\\n  cy.get(\\\"@onClickStub\\\").should(\\\"have.callCount\\\", 2).and(\\\"be.calledWith\\\", 1);\\n  cy.dataCy(\\\"button-2\\\").click().click().click();\\n  cy.get(\\\"@onClick2Stub\\\").should(\\\"have.callCount\\\", 3);\\n};\\n// story-code @end\\n\\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\\n  typeof ClickCount\\n> = (args) => <ClickCount {...args} />;\\nCheckOtherAliasesAndAccessOptions.argTypes = {\\n  onClick: { action: \\\"onClickStub\\\" },\\n};\\nCheckOtherAliasesAndAccessOptions.cy = function () {\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 0);\\n  cy.dataCy(\\\"button\\\").click();\\n\\n  // name on actions is `onClick`\\n  cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // but the action string also functions as an alias\\n  cy.get(\\\"@onClickStub\\\").should(\\\"be.calledOnceWith\\\", 0);\\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\\n  cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledWith\\\", 0);\\n\\n  cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 1);\\n\\n  cy.dataCy(\\\"button\\\")\\n    .click()\\n    .then(() => {\\n      // just proving that `this` access works\\n      const self = this as any;\\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\\n      expect(self[\\\"argTypesRegex.onClick\\\"])\\n        .to.have.callCount(2)\\n        .and.be.calledWith(1);\\n      cy.dataCy(\\\"count\\\").should(\\\"contain\\\", 2);\\n    });\\n};\\n// story-code @end\\n\\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\\n  cy: {\\n    \\\"should stub via argtype regex when no other reasons for stubbing exist\\\":\\n      function () {\\n        cy.dataCy(\\\"button\\\")\\n          .click()\\n          .then(() => {\\n            // confirming that `this` access also works\\n            // @ts-ignore\\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\\n          });\\n        cy.get(\\\"@actions\\\").its(\\\"onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n        cy.get(\\\"@argTypesRegex.onClick\\\").should(\\\"be.calledOnceWith\\\", 0);\\n      },\\n  },\\n};\\n\\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  cyTest: (Story) => {\\n    beforeEach(() => {\\n      cy.spy(() => 1).as(\\\"beforeEachSpy\\\");\\n    });\\n\\n    it(\\\"should call the spy and not the argTypesRegex stub\\\", function () {\\n      // could be alias syntax, but showing variant\\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\\n      cy.dataCy(\\\"button\\\")\\n        .click()\\n        .then(() => {\\n          expect(this.actions.onClick).to.have.callCount(0);\\n          expect(this[\\\"argTypesRegex.onClick\\\"]).to.have.callCount(0);\\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\\n        });\\n    });\\n  },\\n};\\n\\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  args: {\\n    // @ts-ignore\\n    onSomethingElse:\\n      /* istanbul ignore next */ // story-code @skip\\n      () => 1,\\n  },\\n  cy: () => {\\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@argTypesRegex.onSomethingElse\\\").should(\\\"not.be.called\\\");\\n  },\\n  // story-code @skip-start\\n  parameters: {\\n    docs: {\\n      description: {\\n        story: `\\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\\nwithout docgen`,\\n      },\\n    },\\n  },\\n  // story-code @skip-end\\n};\\n\\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\\n  typeof ClickCount\\n> = {\\n  argTypes: {\\n    // @ts-ignore\\n    onSomethingElse: { action: \\\"onSomethingElseAlias\\\" },\\n  },\\n  cy: () => {\\n    cy.get(\\\"@actions\\\").its(\\\"onSomethingElse\\\").should(\\\"not.be.called\\\");\\n    cy.get(\\\"@onSomethingElseAlias\\\").should(\\\"not.be.called\\\");\\n  },\\n};\\n\",\"locationsMap\":{\"stub-actions\":{\"startLoc\":{\"col\":64,\"line\":7},\"endLoc\":{\"col\":1,\"line\":9},\"startBody\":{\"col\":64,\"line\":7},\"endBody\":{\"col\":1,\"line\":9}},\"check-other-aliases-and-access-options\":{\"startLoc\":{\"col\":4,\"line\":28},\"endLoc\":{\"col\":38,\"line\":28},\"startBody\":{\"col\":4,\"line\":28},\"endBody\":{\"col\":38,\"line\":28}}}},}, component: ClickCount };\n\nexport const StubActions: ComponentStoryCy<typeof ClickCount> = (args) => (\n  <ClickCount {...args} />\n);;;\nStubActions.argTypes = {\n  onClick: { action: \"onClickStub\" },\n  onClick2: { action: \"onClick2Stub\" },\n};\nStubActions.cy = () => {\n  cy.dataCy(\"count\").should(\"contain\", 0);\n  cy.dataCy(\"button\").click();\n  cy.get(\"@onClickStub\").should(\"be.calledOnceWith\", 0);\n  cy.dataCy(\"count\").should(\"contain\", 1);\n  cy.dataCy(\"button\").click();\n  cy.get(\"@onClickStub\").should(\"have.callCount\", 2).and(\"be.calledWith\", 1);\n  cy.dataCy(\"button-2\").click().click().click();\n  cy.get(\"@onClick2Stub\").should(\"have.callCount\", 3);\n};\n// story-code @end\n\nexport const CheckOtherAliasesAndAccessOptions: ComponentStoryCy<\n  typeof ClickCount\n> = (args) => <ClickCount {...args} />;\nCheckOtherAliasesAndAccessOptions.argTypes = {\n  onClick: { action: \"onClickStub\" },\n};\nCheckOtherAliasesAndAccessOptions.cy = function () {\n  cy.dataCy(\"count\").should(\"contain\", 0);\n  cy.dataCy(\"button\").click();\n\n  // name on actions is `onClick`\n  cy.get(\"@actions\").its(\"onClick\").should(\"be.calledOnceWith\", 0);\n  // but the action string also functions as an alias\n  cy.get(\"@onClickStub\").should(\"be.calledOnceWith\", 0);\n  // and it's also aliased as argTypesRegex.onClick since the argtypes would have applied\n  cy.get(\"@argTypesRegex.onClick\").should(\"be.calledWith\", 0);\n\n  cy.dataCy(\"count\").should(\"contain\", 1);\n\n  cy.dataCy(\"button\")\n    .click()\n    .then(() => {\n      // just proving that `this` access works\n      const self = this as any;\n      expect(self.actions.onClick).to.have.callCount(2).and.be.calledWith(1);\n      expect(self.onClickStub).to.have.callCount(2).and.be.calledWith(1);\n      expect(self[\"argTypesRegex.onClick\"])\n        .to.have.callCount(2)\n        .and.be.calledWith(1);\n      cy.dataCy(\"count\").should(\"contain\", 2);\n    });\n};\n// story-code @end\n\nexport const ImplicitArgtypeViaRegex: ComponentStoryObjCy<typeof ClickCount> = {\n  cy: {\n    \"should stub via argtype regex when no other reasons for stubbing exist\":\n      function () {\n        cy.dataCy(\"button\")\n          .click()\n          .then(() => {\n            // confirming that `this` access also works\n            // @ts-ignore\n            expect(this.actions.onClick).to.be.calledOnceWith(0);\n          });\n        cy.get(\"@actions\").its(\"onClick\").should(\"be.calledOnceWith\", 0);\n        cy.get(\"@argTypesRegex.onClick\").should(\"be.calledOnceWith\", 0);\n      },\n  },\n};\n\nexport const WithExplicitStubAsPropToStory: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  cyTest: (Story) => {\n    beforeEach(() => {\n      cy.spy(() => 1).as(\"beforeEachSpy\");\n    });\n\n    it(\"should call the spy and not the argTypesRegex stub\", function () {\n      // could be alias syntax, but showing variant\n      cy.mount(<Story onClick={this.beforeEachSpy} />);\n      cy.dataCy(\"button\")\n        .click()\n        .then(() => {\n          expect(this.actions.onClick).to.have.callCount(0);\n          expect(this[\"argTypesRegex.onClick\"]).to.have.callCount(0);\n          expect(this.beforeEachSpy).to.be.calledOnceWith(0);\n        });\n    });\n  },\n};\n\nexport const MockIfProvidedViaArgsRegardlessOfDocgen: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  args: {\n    // @ts-ignore\n    onSomethingElse:\n      /* istanbul ignore next */ // story-code @skip\n      () => 1,\n  },\n  cy: () => {\n    // these won't be called, but asserting not called proves they were stubbed and are stubs/spies\n    cy.get(\"@actions\").its(\"onSomethingElse\").should(\"not.be.called\");\n    cy.get(\"@argTypesRegex.onSomethingElse\").should(\"not.be.called\");\n  },\n  // story-code @skip-start\n  parameters: {\n    docs: {\n      description: {\n        story: `\nProves that you can mock without presence of docgen plugin as long as it comes in as an arg.\nProviding a mock not acceptable by typescript was easier than building a separate pipeline\nwithout docgen`,\n      },\n    },\n  },\n  // story-code @skip-end\n};\n\nexport const MockIfProvidedViaArgTypesRegardlessOfDocgen: ComponentStoryObjCy<\n  typeof ClickCount\n> = {\n  argTypes: {\n    // @ts-ignore\n    onSomethingElse: { action: \"onSomethingElseAlias\" },\n  },\n  cy: () => {\n    cy.get(\"@actions\").its(\"onSomethingElse\").should(\"not.be.called\");\n    cy.get(\"@onSomethingElseAlias\").should(\"not.be.called\");\n  },\n};\n","import { DocsContext, getStoryId } from \"@storybook/addon-docs\";\nimport { Source } from \"@storybook/components\";\nimport React, { createContext, useContext } from \"react\";\nimport dedent from \"ts-dedent\";\n\nimport type { WithCy } from \"../types\";\n\n/** Props for the UnitTest component, mostly to link to story */\nexport type UnitTestProps = {\n  /** name matching the story's name */\n  name?: string;\n  /** id matching the story's name. either name or id must be provided */\n  id?: string;\n  /**\n   * description for tests which have cy function or cyTest formats.\n   * Provides a reasonable default but can opt out with `false`\n   */\n  description?: string | false;\n  /**\n   * Parameters, probably passed in from parent in unitTestDecorator,\n   * though I suppose passing in directly could be useful somehow\n   */\n  parameters?: WithCy<any>;\n};\n\n/** Get entries to map over to then display in each Preview component */\nconst getNormalizedCyTestEntries = (parameters: any, props: UnitTestProps) => {\n  if (!parameters) return [];\n  const { cy, cyTest } = parameters;\n  const defaultDescription = `should pass the following a ${\n    cyTest ? \"cyTest\" : \"cy\"\n  } expectation`;\n  if (cy) {\n    return typeof cy === \"object\"\n      ? Object.entries(cy)\n      : [[props.description ?? defaultDescription, cy]];\n  }\n  if (cyTest) {\n    return [[props.description ?? defaultDescription, cyTest]];\n  }\n  return [];\n};\n\n/** Context for parameters used in unitTestDecorator */\nexport const ParametersContext = createContext({});\n\n/**\n * Display test information for pure unit test stories.\n * This is likey used in mdx files and must have a 'name' or 'id' which would appropriately\n * match to the proper story.\n * See [the task story](https://quotapath.github.io/orphic-cypress/storybook/?path=/docs/cypressutils-tasks--arbitrary-task#literate-testing)\n * for detailed use.\n * ```ts\n * <Story\n *   name=\"ArbitraryTask\"\n *   parameters={{\n *     cy: () =>\n *       cy.arbitraryTask(2).then(($num) => expect($num).to.equal(2)),\n *   }}\n * >\n *   <UnitTest name=\"ArbitraryTask\" />\n * </Story>\n * ```\n *\n * Or by providing the `unitTestDecorator` decorator and setting a `cyUnitTest`\n * parameter to `true`\n */\nexport const UnitTest = (props: UnitTestProps) => {\n  // lots of different possible ways of getting parameters in here\n  const context = useContext(DocsContext);\n  const parametersContext = useContext(ParametersContext);\n  let parameters = props.parameters;\n  const hasContext = context && Object.keys(context).length > 0;\n  const hasParametersContext =\n    parametersContext && Object.keys(parametersContext).length > 0;\n  if (!parameters) {\n    if (hasContext) {\n      const storyId = getStoryId(props, context);\n      const story = context.componentStories().find(({ id }) => id === storyId);\n      parameters = story?.parameters;\n    } else if (hasParametersContext) {\n      parameters = parametersContext;\n    }\n  }\n\n  if (!parameters) return null;\n\n  const cyMap = getNormalizedCyTestEntries(parameters, props);\n\n  const previews = cyMap.map(([key, orgCode], i) => {\n    const code = dedent((orgCode as () => void).toString());\n    return (\n      <div key={key || i}>\n        {key && <div className=\"orphic-cypress-unit-test\">{key}</div>}\n        <Source language=\"tsx\" dark format={false} code={code} />\n      </div>\n    );\n  });\n\n  return <>{previews}</>;\n};\n\n/**\n * A storybook decorator that provides a parameter context for the sake\n * of showing UnitTest components in cypress and storybook canvas as opposed\n * to just docs, and allows display without manually adding a UnitTest component\n * via `cyUnitTest` parameter.\n * TODO: types would be nice, but have been annoying\n */\nexport const unitTestDecorator = (Story: any, context: any) => {\n  const parameters = { ...context.originalStoryFn, ...context.parameters };\n  return (\n    <ParametersContext.Provider value={parameters}>\n      <Story />\n      {context.parameters?.cyUnitTest && (\n        <span data-cy=\"cy-unit-test\">\n          <br />\n          <UnitTest name={context.name} parameters={parameters} />\n        </span>\n      )}\n    </ParametersContext.Provider>\n  );\n};\n","import * as React from \"react\";\n\n/**\n * Check if the first prop of a\n */\nconst isRawMd = (childProps: {\n  mdxType?: string;\n  children?: { props?: { className?: string } };\n}): boolean =>\n  childProps.mdxType === \"pre\" &&\n  childProps.children?.props?.className === \"language-md\";\n\n/** Rendered child, with props */\nexport type RenderedChild = any;\n/** mdx component as it exists after importing via `import someMdx from \"./some.mdx\"` */\nexport type MDX = (props: unknown) => RenderedChild;\n/** Object gathered for each header */\nexport type ParsedMDX = {\n  /** Full content of this segment of markdown including the header */\n  full: RenderedChild[];\n  /** Content of this segment of markdown excluding header */\n  body: RenderedChild[];\n  /** Raw string extracted from 'md' code blocks */\n  md: string;\n};\n/** Function returned for each header, with properties assigned for more specific use cases */\nexport type MDXSegment = {\n  /** Function which is useful passed to parameters.docs.page directly */\n  (): RenderedChild[];\n} & ParsedMDX;\n/** Header in kebab case as key to object of markdown segments */\nexport type HeaderKeyedMDXSegment = { [id: string]: MDXSegment };\n\n/**\n * quick and dirty fifo\n * @private\n */\nexport class Fifo<T, U> {\n  limit: number;\n  _cache: Map<T, U>;\n\n  // TODO: babel was getting upset with `private` keyword\n  constructor(limit = 50, _cache = new Map<T, U>()) {\n    this.limit = limit;\n    this._cache = _cache;\n  }\n\n  get(key: T) {\n    return this._cache.get(key);\n  }\n\n  set(key: T, val: U) {\n    if (this._cache.size === this.limit) {\n      this._cache.delete(this._cache.keys().next().value);\n    }\n    this._cache.set(key, val);\n    return val;\n  }\n}\n\nconst cache = new Fifo<MDX, HeaderKeyedMDXSegment>();\n\n/**\n * simple kebab-case converter for space separated text,\n * returns undefined if str is undefined or null\n * @private\n */\nexport const safeKebabCase = (str?: string | null) =>\n  typeof str === \"string\" ? str.toLowerCase().replace(/ /g, \"-\") : null;\n\n/**\n * Split up an MDX files into headers for easy use in multiple parts of documentation\n * or in multiple files, with some added perks.\n *\n * Currently, this breaks on any header such that a file like\n * ```md\n * # First Component\n *\n * Something\n *\n * ## Second Component\n *\n * \\`\\`\\`md\n * # Second header description\n * This second component does stuff\n * \\`\\`\\`\n * ```\n * becomes essentially\n * ```ts\n * {\n *   \"first-component\": {\n *     full: [<h1>First Component</h1>,<p>Something</p>],\n *     body: [<p>Something</p>],\n *     md: \"\",\n *   },\n *   \"second-component\": {\n *     full: [<h1>Second Component</h1>,<p>Other</p>],\n *     body: [<code>....</code>],\n *     md: \"# Second header description\\nThis second component does stuff\",\n *   },\n * }\n * ```\n * Although actually they'll be functions at those locations that also have those properties,\n * but is `() => full` at invocation. Note how it picks up md code blocks as raw text, suitable\n * for story descriptions.\n *\n *\n * Then you can use it like\n * ```ts\n * import mdx from \"./some.mdx\";\n * const mdxObject = segmentMDX(mdx);\n * // define FirstComponent...\n * FirstComponent.parameters = {\n *   docs: {\n *     page: mdxObject['first-component'],\n *   }\n * };\n * // define SecondComponent...\n * SecondComponent.parameters = {\n *   docs: {\n *     story: {\n *       description: mdxObject['second-component'].md,\n *     }\n *   }\n * };\n * ```\n *\n * And if you needed to combine them you could do something like\n * ```ts\n * docs: {\n *   page: () => [\n *     ...mdxObject[\"first-component\"].full,\n *     ...mdxObject[\"second-component\"].full,\n *   ]\n * }\n * ```\n *\n * Or, in an mdx file like so (real example):\n * ```mdx\n * import { Meta } from \"@storybook/addon-docs\";\n * import readme from \"../../README.md\";\n * import { segmentMDX } from \"orphic-cypress\";\n *\n * <Meta title=\"MockRequests/Overview\" />\n *\n * <>{segmentMDX(readme)[\"intercepting-api-requests\"].full}</>\n *\n * <-- more markdown -->\n * # Further afield\n * ```\n *\n * Uses a dead simple FIFO cache of size 50 just to avoid thinking about memory consumption issues.\n */\nexport const segmentMDX = (\n  mdx: MDX,\n  /** force skipping the cache */\n  force?: boolean\n): HeaderKeyedMDXSegment => {\n  const fromCache = !force && cache.get(mdx);\n  if (fromCache) return fromCache;\n\n  if (typeof mdx !== \"function\") return cache.set(mdx, {});\n\n  const rendered = mdx({});\n\n  let currentId = \"file\";\n\n  const collection: { [id: string]: ParsedMDX } = {\n    file: { full: [], body: [], md: \"\" },\n  };\n\n  React.Children.forEach(rendered.props.children, (child) => {\n    const childrenOfChild = child.props.children;\n    if (/^h\\d$/.test(child.props.mdxType)) {\n      // not sure why exactly the id is sometimes already present\n      currentId = child.props.id || safeKebabCase(childrenOfChild) || \"unknown\";\n      collection[currentId] = { full: [child], body: [], md: \"\" };\n    } else if (collection[currentId]) {\n      collection[currentId].full.push(child);\n      collection[currentId].body.push(child);\n      if (isRawMd(child.props)) {\n        const rawMd = childrenOfChild.props.children;\n        collection[currentId].md += rawMd;\n      }\n    }\n  });\n\n  return cache.set(\n    mdx,\n    Object.fromEntries(\n      Object.entries(collection).map(([k, v]): [string, MDXSegment] => [\n        k,\n        Object.assign(() => v.full, v),\n      ])\n    )\n  );\n};\n","import React from \"react\";\n\nexport type ButtonProps = {\n  /** fire action on click */\n  onClick?: () => void;\n  /** label for the button */\n  label?: string;\n  /** if the button should be disabled or not */\n  disabled?: boolean;\n  /** tag to make test selection easy + stable */\n  dataCy?: string;\n};\n\n/**\n * Just a typical button really\n */\nexport const Button = ({\n  onClick,\n  disabled,\n  label = \"click me\",\n  dataCy = \"button\",\n}: ButtonProps) => (\n  <button onClick={onClick} disabled={disabled} data-cy={dataCy}>\n    {label}\n  </button>\n);\n","import React from \"react\";\nimport { Button, ButtonProps } from \"./Button\";\n\nexport type ComplexButtonProps = ButtonProps & {\n  /** fire action on click with previous click count */\n  onClick?: (prevClickCount: number) => void;\n  /** fire a second action with a different count */\n  onClick2?: (prevClickCount2: number) => void;\n};\n\nconst white = { style: { color: \"white\" } };\nconst leftPad = { style: { paddingLeft: \"10px\", ...white.style } };\n\n/**\n * Two buttons which show individual click counts\n */\nexport const ClickCount = ({\n  onClick,\n  onClick2,\n  ...rest\n}: ComplexButtonProps) => {\n  const [clickCount, setClickCount] = React.useState(0);\n  const [clickCount2, setClickCount2] = React.useState(0);\n  const handleClick =\n    (isCount = true) =>\n    () => {\n      // send in previous click\n      if (isCount) {\n        onClick?.(clickCount);\n        setClickCount(clickCount + 1);\n      } else {\n        onClick2?.(clickCount2);\n        setClickCount2(clickCount2 + 1);\n      }\n    };\n\n  return (\n    <div data-cy=\"click-container\">\n      <span data-cy=\"count\" {...white}>\n        Count is {clickCount}\n      </span>\n      <span {...leftPad}>\n        <Button onClick={handleClick()} {...rest} />\n      </span>\n      <span data-cy=\"count-2\" {...leftPad}>\n        Count 2 is {clickCount2}\n      </span>\n      <span {...leftPad}>\n        <Button dataCy={\"button-2\"} onClick={handleClick(false)} {...rest} />\n      </span>\n    </div>\n  );\n};\n","export * from \"./Button\";\nexport * from \"./ClickCount\";\n","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport { Canvas, Story } from \"@storybook/addon-docs\";\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"fully-skipped\"\n    }}>{`Fully Skipped`}</h1>\n    <p>{`You can full skip test files via the cySkip property on the default export.\nIf you need to completely ignore them instead of marking as pending, see\n`}<a parentName=\"p\" {...{\n        \"href\": \"/docs/ignoring-via-cyincludestories--not-skipped-function\"\n      }}>{`cyIncludeFiles`}</a></p>\n    <Canvas mdxType=\"Canvas\">\n  <Story id=\"skippingandselecting-fullyskipped--skipped\" mdxType=\"Story\" />\n    </Canvas>\n    <Canvas mdxType=\"Canvas\">\n  <Story id=\"skippingandselecting-fullyskipped--another\" mdxType=\"Story\" />\n    </Canvas>\n    <h1 {...{\n      \"id\": \"ignoring-via-cyincludestories\"\n    }}>{`Ignoring Via cyIncludeStories`}</h1>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-md\"\n      }}>{`\\`cyIncludeStories\\` allows similar functionality to includeStories on the default export.\nIt can be used to ensure that only some stories are tested while the others don't\nregister with cypress at all, where [.cySkip](/docs/skippingandselecting-fullyskipped--skipped)\nwill designate them as 'pending'.\n`}</code></pre>\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;","import { segmentMDX } from \"../../../src/storybook/segment-mdx\";\n// @ts-ignore\nimport mdx from \"./index.mdx\";\n\nexport default segmentMDX(mdx);\n","import { DocsContext, Title as SBTitle } from \"@storybook/addon-docs\";\nimport { startCase } from \"lodash\";\nimport React from \"react\";\n\nexport const Title = ({ name, pad }: { name?: string; pad?: boolean }) => {\n  const context = React.useContext(DocsContext);\n  return (\n    <>\n      {pad && <br />}\n      <SBTitle>{startCase(name || context.name)}</SBTitle>\n    </>\n  );\n};\n","export * from \"./Button\";\n// re-exported for convenience\nexport { Title } from \"dot-storybook/components\";\n","import '@storybook/react';","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".orphic-cypress-unit-test {\\n  color: white;\\n  padding-left: 5px;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./.storybook/styles.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,YAAY;EACZ,iBAAiB;AACnB\",\"sourcesContent\":[\".orphic-cypress-unit-test {\\n  color: white;\\n  padding-left: 5px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var map = {\n\t\"./CypressUtils/DataCy.stories.tsx\": \"./stories/CypressUtils/DataCy.stories.tsx\",\n\t\"./CypressUtils/LiterateTestingAndTasks.stories.mdx\": \"./stories/CypressUtils/LiterateTestingAndTasks.stories.mdx\",\n\t\"./FileFormats/CypressTestHooksLikeBeforeEach.stories.tsx\": \"./stories/FileFormats/CypressTestHooksLikeBeforeEach.stories.tsx\",\n\t\"./FileFormats/ExternalTest/index.stories.mdx\": \"./stories/FileFormats/ExternalTest/index.stories.mdx\",\n\t\"./FileFormats/ExternalTest/index.stories.tsx\": \"./stories/FileFormats/ExternalTest/index.stories.tsx\",\n\t\"./FileFormats/StandardCSFButAutomaticallyRenderTested.stories.tsx\": \"./stories/FileFormats/StandardCSFButAutomaticallyRenderTested.stories.tsx\",\n\t\"./FileFormats/StorybookFiles.stories.tsx\": \"./stories/FileFormats/StorybookFiles.stories.tsx\",\n\t\"./MDX/CSFStoriesWithArbitraryMDX/index.stories.tsx\": \"./stories/MDX/CSFStoriesWithArbitraryMDX/index.stories.tsx\",\n\t\"./MDX/DocsInMDX/index.stories.mdx\": \"./stories/MDX/DocsInMDX/index.stories.mdx\",\n\t\"./MDX/DocsInMDX/index.stories.tsx\": \"./stories/MDX/DocsInMDX/index.stories.tsx\",\n\t\"./MDX/MDXAutomaticTestFileFormats/CypressTestHooksLikeBeforeEach.stories.mdx\": \"./stories/MDX/MDXAutomaticTestFileFormats/CypressTestHooksLikeBeforeEach.stories.mdx\",\n\t\"./MDX/MDXAutomaticTestFileFormats/StandardCSFButAutomaticallyRenderTested.stories.mdx\": \"./stories/MDX/MDXAutomaticTestFileFormats/StandardCSFButAutomaticallyRenderTested.stories.mdx\",\n\t\"./MDX/MDXAutomaticTestFileFormats/StorybookFiles.stories.mdx\": \"./stories/MDX/MDXAutomaticTestFileFormats/StorybookFiles.stories.mdx\",\n\t\"./MDX/MDXFileWithExternalTests/index.stories.mdx\": \"./stories/MDX/MDXFileWithExternalTests/index.stories.mdx\",\n\t\"./MockRequests/ExternalTests/index.stories.tsx\": \"./stories/MockRequests/ExternalTests/index.stories.tsx\",\n\t\"./MockRequests/InStoryFile.stories.tsx\": \"./stories/MockRequests/InStoryFile.stories.tsx\",\n\t\"./MockRequests/Overview.stories.mdx\": \"./stories/MockRequests/Overview.stories.mdx\",\n\t\"./Overview.stories.mdx\": \"./stories/Overview.stories.mdx\",\n\t\"./SkippingAndSelecting/FullySkipped.stories.tsx\": \"./stories/SkippingAndSelecting/FullySkipped.stories.tsx\",\n\t\"./SkippingAndSelecting/IgnoringViaCyIncludeStories.stories.tsx\": \"./stories/SkippingAndSelecting/IgnoringViaCyIncludeStories.stories.tsx\",\n\t\"./SkippingAndSelecting/Only.stories.mdx\": \"./stories/SkippingAndSelecting/Only.stories.mdx\",\n\t\"./SkippingAndSelecting/Overview.stories.mdx\": \"./stories/SkippingAndSelecting/Overview.stories.mdx\",\n\t\"./SkippingAndSelecting/SkippedStories.stories.tsx\": \"./stories/SkippingAndSelecting/SkippedStories.stories.tsx\",\n\t\"./StubActions/ExternalTests/index.stories.tsx\": \"./stories/StubActions/ExternalTests/index.stories.tsx\",\n\t\"./StubActions/Overview.stories.mdx\": \"./stories/StubActions/Overview.stories.mdx\",\n\t\"./StubActions/WithDefaultExportSettings.stories.tsx\": \"./stories/StubActions/WithDefaultExportSettings.stories.tsx\",\n\t\"./StubActions/WithStorySettings.stories.tsx\": \"./stories/StubActions/WithStorySettings.stories.tsx\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./stories sync recursive ^\\\\.(?:(?:^%7C\\\\/%7C(?:(?:(?%21(?:^%7C\\\\/)\\\\.).)*?)\\\\/)(?%21\\\\.)(?=.)[^/]*?\\\\.stories\\\\.(mdx%7Cjs%7Cjsx%7Cts%7Ctsx))$\";","/* (ignored) */","\"use strict\";\n\nvar _frameworkImportPath = require(\"@storybook/react\");\n\n/* eslint-disable import/no-unresolved */\n(0, _frameworkImportPath.configure)([require.context('./stories', true, /^\\.(?:(?:^|\\/|(?:(?:(?!(?:^|\\/)\\.).)*?)\\/)(?!\\.)(?=.)[^/]*?\\.stories\\.(mdx|js|jsx|ts|tsx))$/)], module, false);"],"names":[],"sourceRoot":""}